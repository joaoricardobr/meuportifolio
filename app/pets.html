
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análise de Pets IA - Análise Inteligente</title>
    <!-- Tailwind CSS via CDN (Aviso: Melhor instalar para produção) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome para ícones (Adicionado integrity e crossorigin por segurança) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- jsPDF para gerar PDF (Adicionado integrity e crossorigin por segurança) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" integrity="sha512-qZvrmS2ekKPF2mSznUtBP9VJFxsOVfgkvHuh+®L7MMHXGecEoWAYpcADS+QCCLaDYCErJE4+X7ySdw3Sjcnw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos CSS (mantidos da versão anterior com tema azul) */
        /* --- Base & Transitions --- */
        body { font-family: 'Inter', sans-serif; background-color: #f7f8fc; color: #1f2937; transition: background-color 0.3s ease, color 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
        .fade-in { animation: fadeIn 0.4s ease-out forwards; }
        .smooth-transition { transition: all 0.2s ease-in-out; }

        /* --- Dark Theme --- */
        .dark-theme { background-color: #111827; color: #e5e7eb; }
        .dark-theme .card-bg { background-color: #1f2937; }
        .dark-theme .secondary-bg { background-color: #374151; }
        .dark-theme .tertiary-bg { background-color: #4b5563; }
        .dark-theme .text-color-base { color: #e5e7eb; }
        .dark-theme .text-color-secondary { color: #d1d5db; }
        .dark-theme .text-color-muted { color: #9ca3af; }
        .dark-theme .text-color-faint { color: #6b7280; }
        .dark-theme .border-color-light { border-color: #374151; }
        .dark-theme .border-color-base { border-color: #4b5563; }
        .dark-theme .shadow-card { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2); }
        .dark-theme input, .dark-theme select, .dark-theme textarea { background-color: #374151; color: #e5e7eb; border-color: #4b5563; }
        .dark-theme input::placeholder, .dark-theme textarea::placeholder { color: #9ca3af; }
        .dark-theme input:focus, .dark-theme select:focus, .dark-theme textarea:focus { border-color: #60a5fa; box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.3); }
        .dark-theme .dropzone { background-color: #1f2937; border-color: #60a5fa; }
        .dark-theme .dropzone.dragover { background-color: #374151; border-color: #3b82f6; }
        .dark-theme .modal-content { background-color: #1f2937; border: 1px solid #374151; }
        .dark-theme .tab-button { color: #9ca3af; } .dark-theme .tab-button:hover { color: #e5e7eb; } .dark-theme .tab-button.active { color: #93c5fd; border-color: #93c5fd; }
        .dark-theme .icon-button:hover { background-color: #374151; }
        .dark-theme .text-green-600 { color: #6ee7b7; } .dark-theme .bg-green-600 { background-color: #10b981; color: #fff; } .dark-theme .hover\:bg-green-700:hover { background-color: #059669; }
        .dark-theme .text-blue-600 { color: #93c5fd; } .dark-theme .bg-blue-600 { background-color: #60a5fa; color: #111827; } .dark-theme .hover\:bg-blue-700:hover { background-color: #3b82f6; }
        .dark-theme .text-red-600 { color: #f87171; } .dark-theme .bg-red-600 { background-color: #dc2626; color: #fff; } .dark-theme .hover\:bg-red-700:hover { background-color: #b91c1c; }
        .dark-theme .text-teal-600 { color: #5eead4; } .dark-theme .bg-teal-600 { background-color: #14b8a6; color: #fff; } .dark-theme .hover\:bg-teal-700:hover { background-color: #0d9488; }
        .dark-theme .text-orange-500 { color: #fb923c; } .dark-theme .text-purple-500 { color: #c084fc; }
        .dark-theme .history-item { background-color: #1f2937; } .dark-theme .history-item:hover { background-color: #374151; } .dark-theme .history-item img { border: 1px solid #4b5563; }
        .dark-theme .active-view { background-color: #4b5563; } .dark-theme .pagination-button { background-color: #374151; color: #d1d5db; } .dark-theme .pagination-button:hover { background-color: #4b5563; }
        .dark-theme .text-color-heading { color: #f9fafb; }
        .dark-theme .loading-overlay .fa-spinner { color: #60a5fa; }
        .dark-theme .dropzone .icon { color: #93c5fd; }
        .dark-theme .modal-content { scrollbar-color: #718096 #1f2937; } .dark-theme .modal-content::-webkit-scrollbar-track { background: #1f2937; } .dark-theme .modal-content::-webkit-scrollbar-thumb { background: #718096; }
        .dark-theme .report-error-box { color: #fca5a5; background-color: rgba(153, 27, 27, 0.2); border-color: rgba(220, 38, 38, 0.3); }

        /* --- General Styles --- */
        .card-bg { background-color: #ffffff; } .secondary-bg { background-color: #f9fafb; } .tertiary-bg { background-color: #f3f4f6; }
        .text-color-base { color: #1f2937; } .text-color-secondary { color: #374151; } .text-color-muted { color: #6b7280; } .text-color-faint { color: #9ca3af; }
        .border-color-light { border-color: #e5e7eb; } .border-color-base { border-color: #d1d5db; } .shadow-card { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.04); }
        .text-color-heading { color: #111827; }

        /* --- Header --- */
        header { border-bottom: 1px solid; }
        #apiKeyIndicator { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-left: 6px; transition: background-color 0.3s ease; }
        #apiKeyIndicator.valid { background-color: #10b981; } #apiKeyIndicator.invalid { background-color: #ef4444; }

        /* --- Buttons --- */
        .button { padding: 10px 20px; border-radius: 8px; font-weight: 500; display: inline-flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; border: none; line-height: 1.25; box-shadow: 0 1px 2px rgba(0,0,0,0.05); transition: all 0.15s ease-in-out; }
        .button:hover { transform: translateY(-1px); box-shadow: 0 3px 5px rgba(0,0,0,0.07); } .button:active { transform: translateY(0); box-shadow: 0 1px 2px rgba(0,0,0,0.05); } .button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; box-shadow: none; }
        .button-primary { background-color: #3b82f6; color: white; } .dark-theme .button-primary { background-color: #60a5fa; color: #111827; } .button-primary:hover { background-color: #2563eb; } .dark-theme .button-primary:hover { background-color: #3b82f6; }
        .button-secondary { background-color: #e5e7eb; color: #374151; } .dark-theme .button-secondary { background-color: #4b5563; color: #e5e7eb; } .button-secondary:hover { background-color: #d1d5db; } .dark-theme .button-secondary:hover { background-color: #6b7280; }
        .button-danger { background-color: #ef4444; color: white; } .dark-theme .button-danger { background-color: #dc2626; } .button-danger:hover { background-color: #dc2626; } .dark-theme .button-danger:hover { background-color: #b91c1c; }
        .icon-button { padding: 0; width: 36px; height: 36px; border-radius: 50%; font-size: 0.9rem; background-color: transparent; color: #6b7280; box-shadow: none; transition: background-color 0.2s ease, color 0.2s ease; }
        .icon-button:hover { background-color: #f3f4f6; color: #1f2937; } .dark-theme .icon-button { color: #9ca3af; } .dark-theme .icon-button:hover { background-color: #374151; color: #e5e7eb; }

        /* --- Inputs, Selects & Textarea --- */
        input[type="text"], input[type="password"], input[type="file"], select, textarea { padding: 10px 14px; border: 1px solid; border-radius: 8px; background-color: #ffffff; transition: border-color 0.2s ease, box-shadow 0.2s ease; width: 100%; font-size: 0.9rem; border-color: #d1d5db; }
        input[type="text"]:focus, input[type="password"]:focus, select:focus, textarea:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3); }
        select { appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22none%22%20stroke%3D%22%236b7280%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%221.5%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M6%209l6%206%206-6%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 14px center; background-size: 1em; padding-right: 40px; }
        .dark-theme select { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22none%22%20stroke%3D%22%239ca3af%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%221.5%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M6%209l6%206%206-6%22%2F%3E%3C%2Fsvg%3E'); }
        textarea { min-height: 80px; resize: vertical; }

        /* --- Dropzone --- */
        .dropzone { border: 2px dashed; border-radius: 12px; padding: 2rem 1rem; text-align: center; position: relative; min-height: 180px; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; transition: background-color 0.3s ease, border-color 0.3s ease; border-color: #60a5fa; background-color: #eff6ff; }
        .dropzone.dragover { border-color: #3b82f6; background-color: #dbeafe; }
        .dropzone video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 11px; z-index: 1; }
        .dropzone .camera-controls-container { position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); z-index: 2; background-color: rgba(0, 0, 0, 0.65); padding: 0.5rem 0.75rem; border-radius: 8px; display: flex; gap: 0.75rem; }
        #dropzone-content .icon { font-size: 3rem; margin-bottom: 0.75rem; color: #3b82f6; } .dark-theme #dropzone-content .icon { color: #93c5fd; }

        /* --- Tabs --- */
        .tab-list { border-bottom: 1px solid; }
        .tab-button { padding: 0.75rem 1rem; font-weight: 500; font-size: 0.95rem; border-bottom: 2px solid transparent; margin-bottom: -1px; cursor: pointer; color: #6b7280; transition: color 0.2s ease, border-color 0.2s ease; }
        .tab-button:hover { color: #1f2937; } .tab-button.active { color: #2563eb; border-bottom-color: #2563eb; }
        .tab-panel { padding-top: 1.5rem; }

        /* --- Report Section (Pet Themed) --- */
        #reportContentWrapper { max-height: none; overflow-y: visible; padding-right: 0; scrollbar-width: none; } #reportContentWrapper::-webkit-scrollbar { display: none; }
        #reportContent { font-size: 0.95rem; line-height: 1.7; }
        #reportContent hr { border: none; border-top: 1px dashed #d1d5db; margin: 1.5rem 0; }
        .dark-theme #reportContent hr { border-top-color: #4b5563; }
        #reportContent strong { font-weight: 600; }
        #reportContent em { font-style: italic; }
        #reportContent p { margin-bottom: 0.7rem; }
        #reportContent ul, #reportContent ol { margin-left: 1.5rem; margin-bottom: 0.7rem; list-style: revert; } /* Use default list style */
        #reportContent li { margin-bottom: 0.3rem; }

        /* --- History Section --- */
        .history-controls { margin-bottom: 1.25rem; }
        .history-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 1rem; }
        .history-list { display: flex; flex-direction: column; gap: 0.75rem; }
        .history-item { border-radius: 10px; padding: 1rem; display: flex; overflow: hidden; transition: background-color 0.2s ease, box-shadow 0.2s ease; border: 1px solid; }
        .history-item:hover { background-color: #f9fafb; box-shadow: 0 2px 4px rgba(0,0,0,0.04); }
        .history-list .history-item { flex-direction: row; align-items: center; } .history-grid .history-item { flex-direction: column; align-items: stretch; text-align: center; }
        .history-item img { object-fit: cover; border-radius: 6px; background-color: #f3f4f6; border: 1px solid #e5e7eb; } /* Add border to image */
        .history-list .history-item img { width: 56px; height: 56px; margin-right: 1rem; flex-shrink: 0; } .history-grid .history-item img { width: 100%; height: 160px; margin-bottom: 0.75rem; }
        .history-item-content { flex-grow: 1; min-width: 0; }
        .history-item-summary { font-weight: 500; font-size: 0.9rem; line-height: 1.4; margin-bottom: 0.25rem; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; }
        .history-item-meta { font-size: 0.75rem; margin-bottom: 0.25rem; }
        .history-item-actions { display: flex; gap: 0.5rem; } .history-list .history-item-actions { margin-left: 1rem; flex-shrink: 0; } .history-grid .history-item-actions { margin-top: 0.75rem; justify-content: center; }
        .active-view { background-color: #e5e7eb; } .pagination-button { background-color: #e5e7eb; color: #374151; } .pagination-button:hover { background-color: #d1d5db; }
        .dark-theme .history-item img { border-color: #4b5563; } /* Dark theme border */

        /* --- Modal --- */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.65); justify-content: center; align-items: center; padding: 1rem; }
        .modal-content { background-color: #ffffff; margin: auto; padding: 1.5rem 2rem; border-radius: 12px; width: 100%; max-width: 750px; max-height: 90vh; overflow-y: auto; box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2); position: relative; scrollbar-width: thin; scrollbar-color: #a0aec0 #f0f0f0; }
        .modal-content::-webkit-scrollbar { width: 8px; } .modal-content::-webkit-scrollbar-thumb { background: #a0aec0; border-radius: 4px; } .modal-content::-webkit-scrollbar-track { background: #f0f0f0; }
        .dark-theme .modal-content { scrollbar-color: #718096 #1f2937; } .dark-theme .modal-content::-webkit-scrollbar-track { background: #1f2937; } .dark-theme .modal-content::-webkit-scrollbar-thumb { background: #718096; }

        /* --- Notification --- */
        .notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 0.9rem 1.5rem; border-radius: 8px; z-index: 1500; opacity: 0; transition: opacity 0.4s ease, transform 0.4s ease; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15); color: white; font-weight: 500; font-size: 0.9rem; transform: translate(-50%, 20px); }
        .notification.show { opacity: 1; transform: translateX(-50%); }
        .notification.success { background-color: #10b981; } .notification.error { background-color: #ef4444; } .notification.info { background-color: #3b82f6; }

        /* --- Loading Overlay --- */
        .loading-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); z-index: 2000; justify-content: center; align-items: center; } .dark-theme .loading-overlay { background: rgba(17, 24, 39, 0.85); }
        .loading-content { display: flex; align-items: center; gap: 1rem; background: #ffffff; padding: 1.25rem 2rem; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); color: #1f2937; } .dark-theme .loading-content { background: #1f2937; color: #e5e7eb; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .loading-overlay .fa-spinner { font-size: 1.5rem; color: #3b82f6; } .dark-theme .loading-overlay .fa-spinner { color: #60a5fa; }

        /* --- Utility --- */
        .hidden { display: none !important; }
        /* --- Aviso de Erro no Relatório --- */
        .report-error-box { padding: 0.75rem 1rem; margin-bottom: 1rem; border-radius: 0.375rem; border: 1px solid; color: #991b1b; background-color: #fef2f2; border-color: #fecaca;}
        .dark-theme .report-error-box { color: #fca5a5; background-color: rgba(153, 27, 27, 0.2); border-color: rgba(220, 38, 38, 0.3); }
        .report-error-box strong { font-weight: 600;}

    </style>
</head>
<body class="min-h-screen flex flex-col text-color-base">

    <!-- Header -->
    <header class="sticky top-0 z-50 bg-white/90 dark:bg-gray-800/90 backdrop-blur-sm border-b border-color-light dark:border-color-base smooth-transition">
        <div class="container mx-auto px-4 md:px-6 py-3 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <i class="fas fa-paw text-2xl text-blue-600"></i>
                <span class="text-xl font-bold text-color-heading">Análise de Pets IA</span>
            </div>
            <div class="flex items-center gap-3">
                 <div class="text-xs text-color-muted hidden md:flex items-center gap-2" id="apiKeyStatusContainer">API Key: <span id="apiKeyStatusText">Não configurada</span><span id="apiKeyIndicator" class="invalid" title="Status da Chave API"></span></div>
                 <button id="configApiKeyButton" class="icon-button" title="Configurar Chave API"><i class="fas fa-key"></i></button>
                 <button id="themeToggle" class="icon-button" title="Alternar Tema"><i class="fas fa-moon"></i></button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto flex-1 p-4 md:px-6 md:py-8 w-full">

        <!-- Action Zone: Config, Upload & Description -->
        <section class="mb-8 md:mb-12 fade-in">
             <div class="card-bg dark:card-bg border border-color-light dark:border-color-base rounded-xl shadow-card p-5 md:p-8">
                 <div class="grid grid-cols-1 md:grid-cols-12 gap-6 md:gap-8 items-start">
                     <!-- API Key Input -->
                     <div class="md:col-span-4">
                         <h2 class="text-lg font-semibold mb-3 text-color-heading">1. Configurar API</h2>
                         <label for="apiKey" class="block text-sm font-medium mb-1 text-color-secondary">Chave Google AI (Gemini)</label>
                         <input type="password" id="apiKey" placeholder="Cole sua chave aqui..." class="w-full mb-1">
                         <p class="text-xs text-color-muted">Necessária para análise. <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">Obter chave</a></p>
                     </div>

                     <!-- Upload/Camera + Description Zone -->
                     <div class="md:col-span-8 grid grid-cols-1 lg:grid-cols-2 gap-6">
                         <div>
                              <h2 class="text-lg font-semibold mb-3 text-color-heading">2. Enviar Imagem do Pet</h2>
                              <div class="dropzone border-color-base dark:border-color-base card-bg dark:card-bg" id="dropzone">
                                  <video id="cameraPreview" class="hidden" playsinline autoplay muted></video>
                                  <div id="dropzone-content" class="flex flex-col items-center justify-center text-center">
                                      <i class="fas fa-camera-retro icon text-blue-500 dark:text-blue-400"></i>
                                      <p class="text-color-secondary font-medium mb-2">Arraste e solte uma foto do seu pet ou use a câmera</p>
                                      <p class="text-color-muted text-sm mb-4">Formatos: JPG, PNG, WEBP</p>
                                      <div class="flex flex-col sm:flex-row justify-center gap-3">
                                          <button id="uploadButton" class="button button-secondary text-sm">
                                              <i class="fas fa-upload"></i> Selecionar Arquivo
                                          </button>
                                          <button id="cameraButton" class="button button-secondary text-sm">
                                              <i class="fas fa-video"></i> Usar Câmera (1 foto)
                                          </button>
                                      </div>
                                  </div>
                                  <div id="cameraControlsContainer" class="camera-controls-container hidden">
                                       <button id="captureButton" class="button button-danger text-sm px-3 py-2"><i class="fas fa-camera"></i> Capturar & Analisar</button>
                                       <button id="stopCameraButton" class="button button-secondary text-sm px-3 py-2"><i class="fas fa-stop"></i> Parar</button>
                                  </div>
                                   <canvas id="cameraCanvas" class="hidden"></canvas>
                              </div>
                               <input type="file" id="imageInput" accept="image/jpeg, image/png, image/webp" class="hidden">
                         </div>

                         <!-- Área de Descrição -->
                         <div>
                             <h2 class="text-lg font-semibold mb-3 text-color-heading">3. Adicionar Descrição</h2>
                             <label for="petDescription" class="block text-sm font-medium mb-1 text-color-secondary">Detalhes sobre o Pet</label>
                             <textarea id="petDescription" rows="6" placeholder="Informe idade, peso, raça, sintomas, comportamento, alimentação atual e o que deseja saber..." class="w-full"></textarea>
                             <p class="text-xs text-color-muted mt-1">Quanto mais detalhes, melhor a análise da IA.</p>
                         </div>
                     </div>
                 </div>
            </div>
        </section>

        <!-- Results Zone: Tabs for Report & History -->
        <section class="fade-in" style="animation-delay: 0.1s;">
             <div class="card-bg dark:card-bg border border-color-light dark:border-color-base rounded-xl shadow-card overflow-hidden">
                 <div class="tab-list flex border-b border-color-light dark:border-color-base px-4 md:px-6">
                     <button id="tabButtonReport" role="tab" aria-controls="tabPanelReport" aria-selected="true" class="tab-button active"><i class="fas fa-comment-alt mr-2"></i>Análise Atual</button>
                     <button id="tabButtonHistory" role="tab" aria-controls="tabPanelHistory" aria-selected="false" class="tab-button"><i class="fas fa-history mr-2"></i>Histórico</button>
                 </div>
                 <div class="p-5 md:p-8">
                     <div id="tabPanelReport" role="tabpanel" aria-labelledby="tabButtonReport" class="tab-panel">
                         <section id="reportSection">
                             <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-3">
                                 <h3 class="text-xl font-semibold text-color-heading">Resultado da Análise</h3>
                                 <!-- Report Controls - Adicionados botões de Copiar e WhatsApp -->
                                 <div id="reportControls" class="flex items-center gap-1 sm:gap-2 flex-wrap hidden">
                                     <button id="fontDecrease" class="icon-button" title="Diminuir Fonte" disabled><i class="fas fa-minus"></i></button>
                                     <button id="fontIncrease" class="icon-button" title="Aumentar Fonte" disabled><i class="fas fa-plus"></i></button>
                                     <button id="speakButton" class="icon-button" title="Ler Relatório Atual" disabled><i class="fas fa-volume-up"></i></button>
                                     <button id="copyReportButton" class="icon-button text-gray-600 dark:text-gray-400" title="Copiar Relatório Completo" disabled><i class="fas fa-copy"></i></button>
                                     <button id="whatsappShareButton" class="icon-button text-green-600 dark:text-green-400" title="Compartilhar Relatório no WhatsApp" disabled><i class="fab fa-whatsapp"></i></button>
                                     <button id="fullScreenButton" class="icon-button text-blue-600 dark:text-blue-400" title="Ver em Tela Cheia" disabled><i class="fas fa-expand"></i></button>
                                 </div>
                             </div>
                             <div id="reportContentWrapper" class="min-h-[200px]">
                                 <div id="reportContent" class="text-color-secondary">
                                     <p id="reportPlaceholder" class="text-center text-color-muted py-10">Envie a foto e a descrição do seu pet para análise.</p>
                                 </div>
                             </div>
                         </section>
                     </div>
                     <div id="tabPanelHistory" role="tabpanel" aria-labelledby="tabButtonHistory" class="tab-panel hidden">
                         <section id="historySection">
                             <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-5 gap-3">
                                 <h3 class="text-xl font-semibold text-color-heading">Histórico de Análises de Pets</h3>
                                 <div class="flex items-center gap-2 self-end sm:self-center">
                                      <span class="text-sm text-color-muted mr-1">Ver:</span>
                                      <button id="listView" class="icon-button active-view" title="Lista"><i class="fas fa-list"></i></button>
                                      <button id="gridView" class="icon-button" title="Grade"><i class="fas fa-th-large"></i></button>
                                 </div>
                             </div>
                             <div class="history-controls grid grid-cols-1 md:grid-cols-5 gap-3 items-end">
                                 <div class="relative md:col-span-2">
                                     <label for="searchInput" class="block text-xs font-medium mb-1 text-color-muted">Buscar no texto</label>
                                     <input type="text" id="searchInput" placeholder="Ex: vômito, ração, labrador..." class="w-full pl-10 text-sm">
                                     <i class="fas fa-search text-color-faint absolute left-3 bottom-[11px]"></i>
                                 </div>
                                 <div>
                                     <label for="categoryFilter" class="block text-xs font-medium mb-1 text-color-muted">Tipo de Pet (Estimado)</label>
                                     <select id="categoryFilter" class="w-full text-sm">
                                         <option value="">Todos</option>
                                         <option value="Cachorro">Cachorro</option>
                                         <option value="Gato">Gato</option>
                                         <option value="Pássaro">Pássaro</option>
                                         <option value="Outro">Outro</option>
                                         <option value="Indefinido">Indefinido</option>
                                     </select>
                                 </div>
                                  <div>
                                     <label for="sortOrder" class="block text-xs font-medium mb-1 text-color-muted">Ordenar</label>
                                     <select id="sortOrder" class="w-full text-sm">
                                         <option value="recent">Recentes</option><option value="oldest">Antigos</option>
                                     </select>
                                  </div>
                                 <button id="applyFilters" class="button button-primary text-sm h-[38px] mt-auto w-full md:w-auto"><i class="fas fa-filter text-xs"></i> Filtrar</button>
                             </div>
                             <div id="historyContainer" class="history-list min-h-[200px]"></div>
                             <p id="noHistory" class="text-center text-color-muted mt-6 py-10 border-t border-dashed border-color-light dark:border-color-base hidden">Nenhuma análise de pet encontrada no histórico.</p>
                             <div id="pagination" class="mt-6 text-center hidden">
                                 <button id="loadMore" class="button pagination-button dark:pagination-button text-sm"><i class="fas fa-chevron-down"></i> Carregar Mais</button>
                             </div>
                         </section>
                     </div>
                 </div>
             </div>
        </section>

    </main>

    <!-- Footer -->
    <footer class="text-center py-6 mt-10 text-sm text-color-muted border-t border-color-light dark:border-color-base">
        Desenvolvido por João Ricardo | <a href="https://instagram.com/joaoricardo.pe" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">@joaoricardo.pe</a>
        <br><span class="text-xs">IA para observação e análise preliminar de pets. Não substitui consulta veterinária.</span>
    </footer>

    <!-- Modal for Full Report -->
    <div id="reportModal" class="modal">
        <div class="modal-content card-bg dark:card-bg fade-in">
            <div class="flex justify-between items-center mb-5 pb-3 border-b border-color-light dark:border-color-base">
                <h2 class="text-xl font-semibold text-color-heading">Relatório Completo da Análise</h2>
                <button id="closeModal" class="icon-button text-red-600" title="Fechar"><i class="fas fa-times"></i></button>
            </div>
            <div id="modalReportContent" class="mb-6 text-color-secondary"></div>
            <div class="flex flex-wrap justify-center gap-3 pt-4 border-t border-color-light dark:border-color-base">
                 <button id="printButton" class="button button-secondary" title="Imprimir"><i class="fas fa-print"></i> Imprimir</button>
                 <!-- No modal, manter botões existentes -->
                 <button id="whatsappButton" class="button bg-green-600 text-white hover:bg-green-700" title="Compartilhar no WhatsApp"><i class="fab fa-whatsapp"></i> WhatsApp</button>
                 <button id="shareButton" class="button bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600" title="Compartilhar"><i class="fas fa-share-alt"></i> Compartilhar</button>
                 <button id="downloadButton" class="button bg-teal-600 text-white hover:bg-teal-700 dark:bg-teal-500 dark:hover:bg-teal-600" title="Baixar PDF"><i class="fas fa-download"></i> Baixar PDF</button>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification"></div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
         <div class="loading-content">
            <i class="fas fa-spinner fa-spin"></i>
            <span id="loadingMessage">Analisando seu pet...</span>
        </div>
    </div>

    <script>
        // Garante que o jsPDF esteja disponível globalmente
        const { jsPDF } = window.jspdf;

        // --- State Variables (Global Scope) ---
        let currentResultText = ''; // Stores the text of the *last* successful analysis for modal/share
        let currentImageBase64 = '';// Stores the image of the *last* successful analysis for modal/share
        let currentDescription = ''; // Stores the description used for the *last* analysis
        let lastSuccessfulAnalysisHTML = ''; // Stores the formatted HTML of the *last* analysis for modal display
        let fontSize = 15.2; // Default font size for report
        let currentPage = 1; // Current page for history pagination
        const itemsPerPage = 8; // Number of history items per page
        let viewMode = 'list'; // Current history view mode ('list' or 'grid')
        let filterTerm = ''; // Current search term for history
        let sortType = 'recent'; // Current sort type for history ('recent' or 'oldest')
        let selectedCategory = ''; // Current category filter for history
        let db; // IndexedDB database instance
        let cameraStream = null; // Active camera stream object
        let allHistoryItems = []; // In-memory cache of ALL history items loaded from DB
        let synth = window.speechSynthesis; // Speech synthesis API
        let utterance = null; // Current speech utterance being spoken
        let currentApiKey = ''; // API Key stored in localStorage
        let isProcessing = false; // Flag to prevent concurrent API calls

        // --- Constants (Global Scope) ---
        const VALID_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp']; // Accepted image types
        // Disclaimer HTML to prepend to the AI report
        const REPORT_DISCLAIMER_HTML = `<p class="p-3 mb-4 rounded-md bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700/40 text-yellow-800 dark:text-yellow-300 text-sm"><strong><i class="fas fa-exclamation-triangle mr-1"></i> Atenção:</strong> Esta é uma análise preliminar gerada por IA com base na imagem e descrição fornecidas. Ela serve para observação e sugestões gerais, mas <strong>NÃO substitui</strong> a avaliação, diagnóstico ou recomendação de um <strong>médico veterinário qualificado</strong>. Sempre consulte um profissional para questões de saúde do seu pet.</p>`;
        // SVG placeholder for cases where image is not available in history
        const PLACEHOLDER_IMG = 'data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%22150%22%20height%3D%22150%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20150%20150%22%20preserveAspectRatio%3D%22none%22%3E%3Cdefs%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%23holder_150x150%20text%20%7B%20fill%3A%23AAAAAA%3Bfont-weight%3Abold%3Bfont-family%3AArial%2C%20Helvetica%2C%20Open%20Sans%2C%20sans-serif%2C%20monospace%3Bfont-size%3A10pt%20%7D%20%3C%2Fstyle%3E%3C%2Fdefs%3E%3Cg%20id%3D%22holder_150x150%22%3E%3Crect%20width%3D%22150%22%20height%3D%22150%22%20fill%3D%22%23EEEEEE%22%3E%3C%2Frect%3E%3Cg%3E%3Ctext%20x%3D%2240%22%20y%3D%2279.5%22%3ESem%20Imagem%3C%2Ftext%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E';

        // --- IndexedDB Setup (Global Scope) ---
        // Opens or creates the IndexedDB database
        const dbRequest = indexedDB.open('PetAnalysisDB_v1', 1);
        dbRequest.onupgradeneeded = (event) => {
            console.log("DB: Upgrading from version", event.oldVersion, "to", event.newVersion);
            db = event.target.result;
            // Create the 'analyses' object store if it doesn't exist
            if (!db.objectStoreNames.contains('analyses')) {
                const store = db.createObjectStore('analyses', { keyPath: 'id', autoIncrement: true });
                // Create indexes for filtering/sorting
                store.createIndex('timestamp', 'timestamp', { unique: false });
                store.createIndex('category', 'category', { unique: false });
                store.createIndex('text', 'text', { unique: false }); // Index for searching analysis text
                console.log("DB: Object store 'analyses' and indices created.");
            }
            // Add migration logic here for future versions if the schema changes
        };
        dbRequest.onsuccess = (event) => {
            db = event.target.result;
            console.log("DB: Opened successfully.");
            // Load API key and initial history AFTER DB is ready and opened successfully
            loadApiKey();
            loadInitialHistory();
        };
        dbRequest.onerror = (event) => {
            console.error("DB: Error opening database -", event.target.error);
            notify('Erro crítico ao acessar o banco de dados local. O histórico não funcionará.', 'error', 5000);
        };

        // --- Utility Functions (Global Scope) ---
        function showLoading(message = "Analisando seu pet...") {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingMessage = document.getElementById('loadingMessage');
            if (loadingOverlay && loadingMessage) {
                loadingMessage.textContent = message;
                loadingOverlay.style.display = 'flex';
            }
        }
        function hideLoading() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
        }
        function notify(message, type = 'info', duration = 3500) {
            const notification = document.getElementById('notification');
            if (!notification) { console.warn("Elemento de notificação não encontrado."); return; }
            notification.textContent = message;
            // Set class list directly to avoid issues with previous classes
            notification.className = `notification ${type}`;
            // Trigger reflow to ensure transition restarts
            void notification.offsetWidth;
            requestAnimationFrame(() => { notification.classList.add('show'); });
            // Clear any existing timeout for the notification
            if (notification.timeoutId) clearTimeout(notification.timeoutId);
            notification.timeoutId = setTimeout(() => { notification.classList.remove('show'); }, duration);
        }
        function getBase64(file) {
            return new Promise((resolve, reject) => {
                if (!file) return reject(new Error("Arquivo inválido fornecido para getBase64."));
                const reader = new FileReader();
                // Read file as Data URL (Base64)
                reader.readAsDataURL(file);
                reader.onload = () => {
                    // Extract only the Base64 string part (after the comma)
                    resolve(reader.result.split(',')[1]);
                };
                reader.onerror = error => {
                    console.error("Erro ao ler arquivo:", error);
                    reject(error);
                };
            });
        }
        // Formats the raw text response from the API into HTML, including basic markdown conversion
        function formatResult(text, fileName = '') {
            let cleanText = (text || '')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Convert **bold** to <strong>
                .replace(/__(.*?)__/g, '<strong>$1</strong>') // Convert __bold__ to <strong>
                .replace(/\*(.*?)\*/g, '<em>$1</em>')   // Convert *italic* to <em>
                .replace(/_(.*?)_/g, '<em>$1</em>');     // Convert _italic_ to <em>

            // Prepend file name header and convert newlines to <br> tags for HTML display
            let structuredHtml = `<div class="report-file-header text-sm text-color-muted mb-2"><i class="fas fa-image mr-1"></i> Arquivo: ${fileName || 'Desconhecido'}</div>`;
            structuredHtml += cleanText.replace(/\n/g, '<br>'); // Convert line breaks from API text to HTML breaks

            return structuredHtml;
        }
        // Attempts to determine the pet category based on keywords in the analysis text
        function getCategory(text) {
             const lowerText = (text || '').toLowerCase();
             if (lowerText.includes('cachorro') || lowerText.includes('cão') || lowerText.includes('canino')) return 'Cachorro';
             if (lowerText.includes('gato') || lowerText.includes('felino')) return 'Gato';
             if (lowerText.includes('pássaro') || lowerText.includes('ave') || lowerText.includes('calopsita') || lowerText.includes('papagaio')) return 'Pássaro';
             // Add other pet types if needed (e.g., roedor, reptil)
             if (lowerText.includes('animal') || lowerText.includes('pet')) return 'Outro'; // Generic fallback
             return 'Indefinido'; // Default if no type is identified
        }
        // Creates HTML for displaying an error message within the report area
        function createErrorBoxHTML(fileName, errorMessage) {
             return `
                 <div class="report-error-box">
                     <div class="text-sm text-color-muted mb-1"><i class="fas fa-image mr-1"></i> Arquivo: ${fileName || 'Desconhecido'}</div>
                     <strong><i class="fas fa-times-circle mr-1"></i> Erro na Análise:</strong> ${errorMessage}
                 </div>
             `;
         }

        // --- API Key Handling (Global Scope) ---
        function loadApiKey() {
            currentApiKey = localStorage.getItem('geminiApiKey') || '';
            const apiKeyInput = document.getElementById('apiKey');
            // Set input value only if element exists
            if (apiKeyInput) apiKeyInput.value = currentApiKey;
            updateApiKeyStatus(); // Update the status indicator
        }
        function saveApiKey() {
            const apiKeyInput = document.getElementById('apiKey');
            if (!apiKeyInput) return; // Exit if input element not found
            currentApiKey = apiKeyInput.value.trim();
            if (currentApiKey) {
                localStorage.setItem('geminiApiKey', currentApiKey);
                notify('Chave API salva localmente.', 'success');
            } else {
                localStorage.removeItem('geminiApiKey');
                notify('Chave API removida.', 'info');
            }
            updateApiKeyStatus(); // Update the status indicator
        }
        function updateApiKeyStatus() {
             const apiKeyIndicator = document.getElementById('apiKeyIndicator');
             const apiKeyStatusText = document.getElementById('apiKeyStatusText');
             const apiKeyStatusContainer = document.getElementById('apiKeyStatusContainer');
             // Check if all status elements exist before updating
             if (!apiKeyIndicator || !apiKeyStatusText || !apiKeyStatusContainer) {
                 // console.warn("Elementos de status da API Key não encontrados na UI.");
                 return;
             }
             const isValid = !!currentApiKey;
             apiKeyIndicator.classList.toggle('valid', isValid);
             apiKeyIndicator.classList.toggle('invalid', !isValid);
             apiKeyStatusText.textContent = isValid ? 'Configurada' : 'Não configurada';
             apiKeyStatusContainer.title = isValid ? "Chave API configurada." : "Chave API não configurada.";
        }

        // --- File Processing Logic (Global Scope) ---
        // Handles the overall process of taking a file and description and starting the analysis
        async function processFiles(file) {
            // Get necessary UI elements
            const reportContent = document.getElementById('reportContent');
            const reportPlaceholder = document.getElementById('reportPlaceholder');
            const reportControls = document.getElementById('reportControls');
            const speakButton = document.getElementById('speakButton');
            const fullScreenButton = document.getElementById('fullScreenButton');
             const copyReportButton = document.getElementById('copyReportButton'); // New button
             const whatsappShareButton = document.getElementById('whatsappShareButton'); // New button
            const petDescriptionInput = document.getElementById('petDescription');
            const reportSection = document.getElementById('reportSection');

            // Input validation
            if (!file) { notify('Tentativa de processar arquivo inválido.', 'error'); return; }
            if (isProcessing) { notify("Aguarde a análise atual terminar.", "info"); return; }
            if (!currentApiKey) { notify('Por favor, configure sua chave de API Gemini primeiro.', 'error'); document.getElementById('apiKey')?.focus(); return; }

            const fileType = file.type || '';
            if (!VALID_MIME_TYPES.includes(fileType.toLowerCase())) {
                notify(`Tipo de arquivo não suportado (${fileType || 'desconhecido'}). Use JPG, PNG ou WEBP.`, 'error');
                return;
            }

            // Set state to processing and update UI
            isProcessing = true;
            activateTab('report'); // Switch to the report tab
            // Clear previous report content and hide placeholder/controls
            if(reportContent) reportContent.innerHTML = '';
            if(reportPlaceholder) reportPlaceholder.classList.add('hidden');
            if(reportControls) reportControls.classList.add('hidden'); // Hide controls until result
            // Disable action buttons in report controls
            if(speakButton) speakButton.disabled = true;
            if(fullScreenButton) fullScreenButton.disabled = true;
             if(copyReportButton) copyReportButton.disabled = true; // Disable new button
             if(whatsappShareButton) whatsappShareButton.disabled = true; // Disable new button

            // Get the description from the textarea
            const description = petDescriptionInput?.value.trim() || '';

            // Show loading overlay with message
            showLoading(`Analisando ${file.name}...`);

            // Call the core analysis function
            const success = await analyzePetImage(file, description);

            // Hide loading overlay and reset processing flag
            hideLoading();
            isProcessing = false;

            // Update UI based on analysis result
            if (success) {
                // Show controls and enable buttons if analysis was successful
                if(reportControls) reportControls.classList.remove('hidden');
                if(speakButton) speakButton.disabled = false;
                if(fullScreenButton) fullScreenButton.disabled = false;
                 if(copyReportButton) copyReportButton.disabled = false; // Enable new button
                 if(whatsappShareButton) whatsappShareButton.disabled = false; // Enable new button

                notify(`Análise de '${file.name}' concluída!`, 'success');
            } else {
                // Show placeholder with error message if analysis failed
                if(reportPlaceholder) {
                    reportPlaceholder.classList.remove('hidden');
                    reportPlaceholder.textContent = "Falha ao analisar imagem/descrição.";
                }
                // Error message already displayed by analyzePetImage
            }
            // Scroll to the report section
            if(reportSection) reportSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // --- Core Functionality: analyzePetImage (Global Scope) ---
        // Sends the image and description to the Gemini API for analysis
        async function analyzePetImage(file, description) {
             let base64Image;
             let analysisText = '';
             let analysisHTML = '';
             const reportContent = document.getElementById('reportContent'); // Get element reference

            try {
                // 1. Convert image to Base64
                base64Image = await getBase64(file);
                const mimeType = file.type;

                // 2. Prepare the API request URL
                const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${currentApiKey}`;

                // ***** DETAILED PET PROMPT *****
                // Instructions for the AI model on how to perform the analysis and format the output
                const petPrompt = `Você é um especialista em saúde animal, nutrição pet e comportamento veterinário. Atue em português do Brasil. Seu objetivo é analisar a imagem fornecida e a descrição do usuário sobre um pet (cão, gato ou outro) e gerar um relatório informativo, seguindo ESTRITAMENTE o formato abaixo.

**Instruções Detalhadas:**
1.  **Análise da Imagem:** Observe atentamente a imagem (espécie, porte, condição corporal, pelagem, postura, sinais visuais óbvios).
2.  **Integração da Descrição:** Use a descrição do usuário como contexto crucial (idade, peso, raça, sintomas, comportamento, alimentação, dúvidas).
3.  **Geração do Relatório (Formato Obrigatório):** Use EXATAMENTE os títulos abaixo em negrito. Seja conciso e direto.
    *   **Resumo do Pet:** Compile as informações básicas disponíveis (espécie inferida ou informada, raça se aplicável, idade e peso se informados, características gerais da imagem).
    *   **Análise de Saúde:** Com base nos sintomas descritos e observações da imagem, liste possíveis condições de saúde ou áreas que merecem atenção. Indique sinais de alerta claros. Classifique o nível de risco percebido (baixo, médio, alto) para a necessidade de atenção veterinária, justificando brevemente. **NÃO FAÇA DIAGNÓSTICOS DEFINITIVOS.** Use "pode indicar", "sugere", "requer avaliação".
    *   **Alimentação Indicada:** Sugira um tipo geral de alimentação (ração adequada, dieta caseira com acompanhamento). Mencione alimentos permitidos (moderados) e proibidos. Adapte à idade, porte, condições.
    *   **Cuidados Especiais:** Aponte restrições alimentares, necessidade de suplementos (com cautela e recomendação de consultar vet), cuidados específicos da raça/idade.
    *   **Recomendação Veterinária:** Indique CLARAMENTE se deve procurar um veterinário e a urgência (Emergência, Consulta, Rotina, Observação).
    *   **Dicas Extras:** Dê 2-3 dicas práticas de cuidados gerais relevantes (exercícios, higiene, vermifugação, ambiente).
4.  **Linguagem:** Clara, empática, responsável, objetiva. Evite jargões.
5.  **Informações Insuficientes:** Se a descrição for vaga, explique educadamente (após tentar analisar o possível) quais informações adicionais seriam importantes (idade, peso, raça específica, detalhes dos sintomas, alimentação atual).
6.  **Disclaimer:** Será adicionado automaticamente pelo sistema. Não o inclua.

**Descrição Fornecida pelo Usuário:**
---
${description || "Nenhuma descrição adicional fornecida."}
---

Analise a imagem e a descrição e forneça o relatório formatado.`;
                // ***** END OF PROMPT *****

                // 3. Prepare the request body for the API call
                 const requestBody = {
                     contents: [{ parts: [{ text: petPrompt }, { inline_data: { mime_type: mimeType, data: base64Image } }] }],
                     generationConfig: { temperature: 0.45 }, // Controls creativity/randomness
                     // Safety settings to block potentially harmful content
                     safetySettings: [
                          { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                          { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                          { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                          { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                     ]
                 };

                 // 4. Send the API request
                 console.log("API: Enviando requisição...");
                 const response = await fetch(GEMINI_API_URL, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify(requestBody)
                 });
                 console.log(`API: Status ${response.status}`);
                 const responseData = await response.json(); // Parse the JSON response

                 // 5. Process the API response
                 if (!response.ok) { // Check for HTTP errors (status codes outside 2xx)
                      console.error(`API Error (${file.name}):`, JSON.stringify(responseData, null, 2));
                      const errorDetail = responseData?.error?.message || `Erro ${response.status}.`;
                      let userMessage = `Falha na comunicação com a IA (${errorDetail})`; // Generic error message
                      // More specific messages for common API errors
                      if (response.status === 400 && errorDetail.toLowerCase().includes('api key')) userMessage = "Chave API inválida. Verifique se está correta.";
                      else if (response.status === 429) userMessage = "Limite de requisições da API atingido. Tente novamente mais tarde.";
                      // Check for safety blocks indicated in the response
                      else if (responseData?.promptFeedback?.blockReason) {
                          userMessage = `Análise bloqueada por segurança (${responseData.promptFeedback.blockReason}). Tente usar uma imagem ou descrição diferente.`;
                      }
                      // Throw an error to be caught below
                      throw new Error(userMessage);
                 }

                 // Check for unexpected API responses (e.g., no candidates, no text)
                 if (!responseData.candidates?.[0]?.content?.parts?.[0]?.text) {
                     let reason = "A API retornou uma resposta inesperada ou vazia.";
                      // Check if the analysis was stopped by the AI
                      if (responseData.candidates?.[0]?.finishReason && responseData.candidates[0].finishReason !== "STOP") {
                         reason = `Análise interrompida pela IA (${responseData.candidates[0].finishReason}).`;
                     } // Safety block reason might also be in promptFeedback here
                      else if (responseData?.promptFeedback?.blockReason) {
                          reason = `Análise bloqueada (${responseData.promptFeedback.blockReason}).`;
                      }
                     console.error("API Response Invalid:", JSON.stringify(responseData, null, 2));
                     throw new Error(reason);
                 }

                 // Extract the generated text from the API response
                 analysisText = responseData.candidates[0].content.parts[0].text;
                 console.log("API Response Text:", analysisText.substring(0, 200) + "..."); // Log snippet of the text

                 // 6. Format the result and add the disclaimer HTML
                 analysisHTML = REPORT_DISCLAIMER_HTML + formatResult(analysisText, file.name);
                 // Display the formatted result in the report area
                 if (reportContent) reportContent.innerHTML = analysisHTML;

                 // 7. Update global state variables with the successful analysis data
                 currentResultText = analysisText; // Raw text for copy/speak
                 currentImageBase64 = base64Image; // Base64 image for modal/PDF
                 currentDescription = description; // Description used
                 lastSuccessfulAnalysisHTML = analysisHTML; // Formatted HTML for modal

                 // 8. Save the analysis to IndexedDB history
                 saveToHistory(analysisText, base64Image, getCategory(analysisText), file.name, description);
                 return true; // Indicate success
            } catch (error) {
                // Handle any errors that occurred during the process (API call, Base64 conversion, etc.)
                console.error(`Analysis Error (${file?.name}):`, error);
                // Display an error box in the report area
                if(reportContent) reportContent.innerHTML = createErrorBoxHTML(file?.name || 'arquivo', error.message);
                // Show a notification to the user
                notify(`Erro ao analisar ${file?.name || 'pet'}: ${error.message}`, 'error', 7000); // More time for error message
                return false; // Indicate failure
            } finally {
                // Cleanup actions that run regardless of success or failure
                const imageInput = document.getElementById('imageInput');
                if(imageInput) imageInput.value = ''; // Clear the file input
                stopCamera(); // Ensure camera is stopped if it was used
                console.log("Analysis process finished for:", file?.name || 'arquivo');
            }
        }

        // --- History Management (Global Scope) ---
        // Saves an analysis result to IndexedDB
        function saveToHistory(text, imageBase64, category, fileName = 'Analise_Pet', description = '') {
            if (!db) { console.warn("DB not ready for saving."); return; }
            const analysisData = { text, imageBase64, timestamp: new Date().toISOString(), category, fileName, description };
            try {
                const transaction = db.transaction(['analyses'], 'readwrite');
                const store = transaction.objectStore('analyses');
                const request = store.add(analysisData); // Add the data to the object store
                request.onsuccess = (e) => {
                    analysisData.id = e.target.result; // Get the auto-generated ID
                    allHistoryItems.unshift(analysisData); // Add the new item to the front of the in-memory cache
                    console.log("DB: Analysis saved, ID:", analysisData.id);
                     // No need to re-render history here, it's done when switching tabs or filtering
                };
                request.onerror = (event) => {
                    console.error("DB: Error saving record -", event.target.error);
                    notify('Erro ao salvar no histórico.', 'error');
                };
            } catch (dbError) {
                console.error("DB: Error starting save transaction -", dbError);
                notify('Erro de banco de dados ao salvar.', 'error');
            }
        }
        // Loads all history items from IndexedDB into memory when the app starts or tab is switched
        function loadInitialHistory() {
            if (!db) { console.warn("DB not available for loading history."); return; }
             const historyContainer = document.getElementById('historyContainer'); // Get element reference
            // Avoid reloading if already loaded in memory AND the history tab is ready (not showing loading)
            if (allHistoryItems.length > 0 && historyContainer && !historyContainer.innerHTML.includes('Carregando')) {
                 console.log("History: Already in memory. Rendering with current filters.");
                 applyFiltersAndRenderHistory(); // Just re-render if data is already there
                 return;
            }
            // If not loaded, show loading indicator and fetch from DB
            if (!historyContainer) {
                 console.warn("History container element not found.");
                 return; // Cannot proceed without the container
            }

            showLoading("Carregando histórico de pets..."); // Show global loading
            historyContainer.innerHTML = '<p class="text-center text-color-muted py-10">Carregando...</p>'; // Show loading in the history panel

             try {
                 const transaction = db.transaction(['analyses'], 'readonly');
                 const store = transaction.objectStore('analyses');
                 const request = store.getAll(); // Get all records from the store
                 request.onsuccess = () => {
                     allHistoryItems = request.result || []; // Store results in the global array
                     console.log(`History: Loaded ${allHistoryItems.length} items from DB.`);
                     applyFiltersAndRenderHistory(); // Apply filters/sort and render the first page
                     hideLoading(); // Hide global loading
                 };
                 request.onerror = (event) => {
                      console.error("DB: Error loading history -", event.target.error);
                      notify('Erro ao carregar histórico.', 'error');
                      const historyContainer = document.getElementById('historyContainer'); // Re-get element
                      const noHistory = document.getElementById('noHistory'); // Re-get element
                      // Display error state in UI
                      if(historyContainer) historyContainer.innerHTML = '';
                      if(noHistory) { noHistory.classList.remove('hidden'); noHistory.textContent = "Erro ao carregar histórico."; }
                      hideLoading();
                 };
             } catch(dbError) {
                 console.error("DB: Error starting load transaction -", dbError);
                 notify('Erro de banco de dados ao carregar histórico.', 'error');
                 const historyContainer = document.getElementById('historyContainer');
                 const noHistory = document.getElementById('noHistory');
                 if(historyContainer) historyContainer.innerHTML = '';
                 if(noHistory) { noHistory.classList.remove('hidden'); noHistory.textContent = "Erro ao carregar histórico."; }
                 hideLoading();
             }
        }
        // Filters and sorts the in-memory history items based on current UI filters
        function getFilteredAndSortedHistory() {
              let filtered = [...allHistoryItems]; // Start with a copy of all items
              // Apply text filter (search in text, file name, and description)
              if (filterTerm) {
                   const lowerFilter = filterTerm.toLowerCase();
                   filtered = filtered.filter(item =>
                       (item.text || '').toLowerCase().includes(lowerFilter) ||
                       (item.fileName || '').toLowerCase().includes(lowerFilter) ||
                       (item.description || '').toLowerCase().includes(lowerFilter)
                   );
              }
              // Apply category filter
              if (selectedCategory) { filtered = filtered.filter(item => item.category === selectedCategory); }
              // Apply sort order
              filtered.sort((a, b) => sortType === 'oldest' ? new Date(a.timestamp) - new Date(b.timestamp) : new Date(b.timestamp) - new Date(a.timestamp));
              return filtered;
        }

        // --- Rendering History (Global Scope) ---
        // Applies current filters and sort, then renders the first page of history
        function applyFiltersAndRenderHistory() {
            // Get filter/sort element values
            const searchInput = document.getElementById('searchInput');
            const sortOrder = document.getElementById('sortOrder');
            const categoryFilter = document.getElementById('categoryFilter');
            if (!searchInput || !sortOrder || !categoryFilter) {
                 console.warn("Elementos de filtro/ordenação do histórico não encontrados.");
                 return; // Cannot apply filters without elements
            }
            filterTerm = searchInput.value.trim();
            sortType = sortOrder.value;
            selectedCategory = categoryFilter.value;
            currentPage = 1; // Reset to the first page when filters are applied
            renderHistory(); // Start rendering from the first page
        }
        // Renders the history items for the current page based on the current view mode
        function renderHistory() {
             // Get necessary UI elements
             const historyContainer = document.getElementById('historyContainer');
             const noHistory = document.getElementById('noHistory');
             const pagination = document.getElementById('pagination');
             const loadMore = document.getElementById('loadMore');
             const listView = document.getElementById('listView');
             const gridView = document.getElementById('gridView');
             if (!historyContainer || !noHistory || !pagination || !loadMore || !listView || !gridView) {
                 console.warn("Um ou mais elementos do histórico não foram encontrados para renderização.");
                 return; // Cannot render without elements
             }

             const filteredItems = getFilteredAndSortedHistory(); // Get filtered and sorted list
             console.log(`History: Rendering page ${currentPage} (${viewMode} view) with ${filteredItems.length} total filtered items.`);

             // Show/hide "No history found" message
             noHistory.classList.toggle('hidden', filteredItems.length > 0 || allHistoryItems.length === 0);
             noHistory.classList.toggle('block', filteredItems.length === 0 && allHistoryItems.length > 0);
             noHistory.textContent = allHistoryItems.length === 0 ? "Nenhuma análise de pet encontrada no histórico." : "Nenhuma análise encontrada com os filtros atuais.";

             // Calculate the items for the current page
             const start = (currentPage - 1) * itemsPerPage;
             const end = start + itemsPerPage;
             const paginatedItems = filteredItems.slice(start, end);

             // Set the class for list or grid view
             historyContainer.className = `min-h-[200px] ${viewMode === 'grid' ? 'history-grid' : 'history-list'}`;
             // Clear container ONLY if rendering the first page (to allow "Load More")
             if (currentPage === 1) { historyContainer.innerHTML = ''; }

             // Create and append HTML for each item on the current page
             const fragment = document.createDocumentFragment(); // Use fragment for performance
             paginatedItems.forEach(item => {
                 const element = document.createElement('div');
                 element.innerHTML = createHistoryItemHTML(item).trim(); // Create item HTML
                 if (element.firstElementChild) fragment.appendChild(element.firstElementChild); // Append the actual element
             });
             historyContainer.appendChild(fragment); // Append all items to the container

             // Re-attach event listeners to the new items (or the container if using delegation)
             addHistoryItemListeners(historyContainer);

             // Show/hide "Load More" button
             const hasMoreItems = end < filteredItems.length;
             pagination.classList.toggle('hidden', !hasMoreItems);
             loadMore.disabled = !hasMoreItems;

             // Update active state for view mode buttons
             listView.classList.toggle('active-view', viewMode === 'list');
             gridView.classList.toggle('active-view', viewMode === 'grid');
        }
        // Attaches click listeners to view and delete buttons within a container
        function addHistoryItemListeners(container) {
            if (!container) return;
            // Attach listener for 'View' buttons using data-id
            container.querySelectorAll('.view-btn[data-id]').forEach(viewBtn => {
                const id = parseInt(viewBtn.dataset.id);
                if (isNaN(id) || viewBtn.dataset.listenerAttached) return; // Skip if ID is not a number or listener already attached
                viewBtn.onclick = () => viewAnalysis(id); // Attach click handler
                viewBtn.dataset.listenerAttached = 'true'; // Mark as attached
            });
            // Attach listener for 'Delete' buttons using data-id
            container.querySelectorAll('.delete-btn[data-id]').forEach(deleteBtn => {
                const id = parseInt(deleteBtn.dataset.id);
                 if (isNaN(id) || deleteBtn.dataset.listenerAttached) return;
                 deleteBtn.onclick = () => deleteAnalysis(id);
                 deleteBtn.dataset.listenerAttached = 'true';
            });
        }
        // Generates the HTML string for a single history item preview
        function createHistoryItemHTML(item) {
            // Format timestamp
            const date = new Date(item.timestamp).toLocaleString('pt-BR', { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit' });

            // Create a short summary from the analysis text
            const firstSentenceMatch = (item.text || '').match(/^(.*?[\.!?])(?:\s|$)/); // Find the first sentence
            let summaryText = firstSentenceMatch ? firstSentenceMatch[1].trim() : (item.text || '').substring(0, 90).replace(/\n/g, ' '); // Use first sentence or snippet
            summaryText = summaryText.replace(/<[^>]*>/g, '').replace(/[\*_#]+/g, '').trim(); // Clean up markdown/html
            if ((item.text || '').length > 90 && !firstSentenceMatch) summaryText += '...'; // Add ellipsis if truncated

            // Determine category and color
            const category = item.category || 'Indefinido';
            let categoryColor = 'text-color-muted';
             if (category === 'Cachorro') categoryColor = 'text-orange-600 dark:text-orange-400';
             else if (category === 'Gato') categoryColor = 'text-purple-600 dark:text-purple-400';
             else if (category === 'Pássaro') categoryColor = 'text-teal-600 dark:text-teal-400';
             else if (category === 'Outro') categoryColor = 'text-blue-600 dark:text-blue-400';

            // Image source (Base64 or placeholder)
            const imageSrc = item.imageBase64 ? `data:image/jpeg;base64,${item.imageBase64}` : PLACEHOLDER_IMG;
            const fileName = item.fileName || 'Analise_Pet';

            // Return the full HTML string for the history item
             return `
                 <div class="history-item card-bg dark:history-item border border-color-light dark:border-color-base" data-id="${item.id}">
                     <img src="${imageSrc}" alt="Imagem de ${fileName}" loading="lazy" class="border border-color-base dark:history-item-img">
                     <div class="history-item-content text-color-secondary dark:text-color-secondary">
                          <p class="history-item-summary text-color-base dark:text-color-base">${summaryText || 'Análise sem texto.'}</p>
                         <p class="history-item-meta text-color-muted dark:text-color-muted">
                            <span class="${categoryColor} font-medium">${category}</span> • ${fileName} • ${date}
                         </p>
                         ${item.description ? `<p class="text-xs italic text-color-faint mt-1 truncate" title="Descrição: ${item.description}">Desc: "${item.description.substring(0, 50)}..."</p>` : ''}
                     </div>
                     <div class="history-item-actions">
                         <button data-id="${item.id}" class="view-btn icon-button text-blue-600 dark:text-blue-400" title="Visualizar Análise Completa"><i class="fas fa-eye"></i></button>
                         <button data-id="${item.id}" class="delete-btn icon-button text-red-600 dark:text-red-400" title="Excluir Análise"><i class="fas fa-trash"></i></button>
                     </div>
                 </div>`;
        }
        // Loads a specific analysis from history and displays it in the main report area and modal
        function viewAnalysis(id) {
             if (!db) return notify("Banco de dados não disponível.", "error");
             if (isNaN(id)) return notify("ID inválido para visualização.", "error");
             try {
                 const transaction = db.transaction(['analyses'], 'readonly');
                 const store = transaction.objectStore('analyses');
                 const request = store.get(id); // Get the analysis record by ID
                 request.onsuccess = () => {
                     const analysis = request.result;
                     // Get necessary UI elements (again, for safety inside async callback)
                     const reportContent = document.getElementById('reportContent');
                     const modalReportContent = document.getElementById('modalReportContent');
                     const reportControls = document.getElementById('reportControls');
                     const speakButton = document.getElementById('speakButton');
                     const fullScreenButton = document.getElementById('fullScreenButton');
                      const copyReportButton = document.getElementById('copyReportButton'); // New button
                      const whatsappShareButton = document.getElementById('whatsappShareButton'); // New button
                     const reportPlaceholder = document.getElementById('reportPlaceholder');
                     const reportSection = document.getElementById('reportSection');

                     if (analysis && reportContent && modalReportContent && reportControls && speakButton && fullScreenButton && copyReportButton && whatsappShareButton && reportPlaceholder && reportSection) {
                         // Update global state variables with loaded data
                         currentResultText = analysis.text || '';
                         currentImageBase64 = analysis.imageBase64 || '';
                         currentDescription = analysis.description || '';
                         // Format the report HTML
                         const formattedResult = REPORT_DISCLAIMER_HTML + formatResult(analysis.text, analysis.fileName);
                         lastSuccessfulAnalysisHTML = formattedResult; // Store for the modal

                         // Display in the main report area
                         reportContent.innerHTML = formattedResult;
                         reportPlaceholder.classList.add('hidden'); // Hide placeholder
                         // Update modal content
                         modalReportContent.innerHTML = formattedResult;

                         // Show report controls and enable buttons based on whether there's text
                         reportControls.classList.remove('hidden');
                         speakButton.disabled = !currentResultText;
                         fullScreenButton.disabled = !currentResultText;
                          copyReportButton.disabled = !currentResultText; // Enable/Disable new button
                          whatsappShareButton.disabled = !currentResultText; // Enable/Disable new button

                         activateTab('report'); // Switch to the report tab
                         reportSection.scrollIntoView({ behavior: 'smooth', block: 'start' }); // Scroll to view
                         notify(`Visualizando análise de '${analysis.fileName || 'histórico'}'`, 'info');
                     } else if (!analysis) {
                         notify("Análise não encontrada no histórico.", "error");
                     } else {
                         console.error("UI elements missing for viewAnalysis or data issue.");
                         notify("Erro interno ao exibir a análise do histórico.", "error");
                     }
                 };
                 request.onerror = (event) => {
                     notify('Erro ao carregar análise do histórico.', 'error');
                     console.error("DB Get Error:", event.target.error);
                 };
             } catch (dbError) {
                 console.error("DB Transaction Error (view):", dbError);
                 notify('Erro de banco de dados ao visualizar análise.', 'error');
             }
        }
        // Deletes an analysis record from IndexedDB and updates the in-memory cache and UI
        function deleteAnalysis(id) {
             if (!db) return notify("Banco de dados não disponível.", "error");
             if (isNaN(id)) return notify("ID inválido para exclusão.", "error");
             // Confirm deletion with the user
             if (!confirm("Tem certeza que deseja excluir esta análise de pet do histórico? Esta ação não pode ser desfeita.")) {
                 return; // Cancel if user clicks Cancel
             }
             try {
                 const transaction = db.transaction(['analyses'], 'readwrite');
                 const store = transaction.objectStore('analyses');
                 const request = store.delete(id); // Delete the record by ID
                 request.onsuccess = () => {
                     notify('Análise excluída do histórico!', 'success');
                     // Remove the item from the in-memory cache
                     allHistoryItems = allHistoryItems.filter(item => item.id !== id);
                     // Re-render the history view to reflect the deletion
                     applyFiltersAndRenderHistory();
                 };
                 request.onerror = (event) => {
                     notify('Erro ao excluir análise do histórico.', 'error');
                     console.error("DB Delete Error:", event.target.error);
                 };
             } catch (dbError) {
                  console.error("DB Transaction Error (delete):", dbError);
                  notify('Erro de banco de dados ao excluir análise.', 'error');
             }
        }

        // --- Camera Functions (Global Scope) ---
        // Starts the camera stream and updates the UI
        async function startCamera() {
            // Check for processing flag, camera support, and API key
            if (isProcessing) { notify("Aguarde análise.", "info"); return; }
            if (!navigator.mediaDevices?.getUserMedia) { notify("Navegador não suporta câmera.", "error", 5000); return; }
            if (!currentApiKey) { notify('Configure API Key.', 'error'); document.getElementById('apiKey')?.focus(); return; }

            stopCamera(); // Stop any existing camera stream
            showLoading("Iniciando câmera..."); // Show loading indicator

            try {
                 // Try accessing the rear camera first
                 const constraints = { video: { facingMode: "environment" } };
                 let stream = null;
                 try {
                     stream = await navigator.mediaDevices.getUserMedia(constraints);
                     console.log("Using rear camera.");
                 } catch (err) {
                     // If rear camera fails, try the default camera (often front-facing)
                     console.warn("Rear camera failed, trying default:", err.name, err.message);
                     stream = await navigator.mediaDevices.getUserMedia({ video: true });
                     console.log("Using default camera.");
                 }
                 cameraStream = stream; // Assign the successful stream to the global variable

                 // Get UI elements for camera preview and controls
                 const cameraPreview = document.getElementById('cameraPreview');
                 const cameraControlsContainer = document.getElementById('cameraControlsContainer');
                 const dropzoneContent = document.getElementById('dropzone-content');
                 if (!cameraPreview || !cameraControlsContainer || !dropzoneContent) throw new Error("Elementos UI câmera não encontrados.");

                 // Set the video source and wait for metadata/play
                 cameraPreview.srcObject = cameraStream;
                 await new Promise((resolve, reject) => {
                     cameraPreview.onloadedmetadata = resolve; // Resolve when metadata loaded
                     cameraPreview.onerror = reject; // Reject on video error
                 });
                 await cameraPreview.play(); // Start playing the video stream

                 // Update UI to show camera preview and controls, hide dropzone content
                 cameraPreview.classList.remove('hidden');
                 cameraControlsContainer.classList.remove('hidden');
                 dropzoneContent.classList.add('hidden');
                 hideLoading(); // Hide loading indicator
                 notify("Câmera iniciada!", "info"); // Notify user

             } catch (err) { // Catch any errors during camera access
                 hideLoading();
                 console.error("Camera Start Error:", err.name, err.message); // Log the error details
                 let errorMsg = `Erro câmera: ${err.message}`; // Default message

                 // Provide more user-friendly messages for common errors
                 if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                     errorMsg = "Permissão da câmera negada. Verifique as configurações do seu navegador para este site e permita o acesso à câmera. Procure um ícone (cadeado ou câmera) na barra de endereços ou vá em Configurações > Privacidade e Segurança > Permissões do Site.";
                 } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                     errorMsg = "Nenhuma câmera foi encontrada no seu dispositivo.";
                 } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                     errorMsg = "Não foi possível acessar a câmera. Ela pode estar sendo usada por outro aplicativo ou página.";
                 } else if (err.name === 'OverconstrainedError') {
                     errorMsg = `A câmera solicitada não atende aos requisitos ou não está disponível. (${err.message})`;
                 } else if (err.name === 'AbortError') {
                     errorMsg = "O acesso à câmera foi abortado, possivelmente por uma ação do usuário ou do sistema.";
                 } else if (err.name === 'TypeError') {
                      errorMsg = "Erro de configuração ao tentar acessar a câmera.";
                 }
                 // Suggest using file upload as an alternative
                 errorMsg += " Você ainda pode enviar uma foto selecionando um arquivo.";

                 // Show error notification
                 notify(errorMsg, "error", 7000); // Show for longer duration
                 stopCamera(); // Ensure cleanup on error state
             }
        }
        // Stops the active camera stream and resets UI elements
        function stopCamera() {
            if (cameraStream) {
                // Stop all tracks associated with the stream (video, audio)
                cameraStream.getTracks().forEach(track => track.stop());
                console.log("Camera stream stopped.");
            }
            cameraStream = null; // Clear the global stream variable

            // Hide camera UI elements and show dropzone content
            const cameraPreview = document.getElementById('cameraPreview');
            const cameraControlsContainer = document.getElementById('cameraControlsContainer');
            const dropzoneContent = document.getElementById('dropzone-content');
            if (cameraPreview) { cameraPreview.srcObject = null; cameraPreview.classList.add('hidden'); }
            if (cameraControlsContainer) cameraControlsContainer.classList.add('hidden');
            if (dropzoneContent) dropzoneContent.classList.remove('hidden');
        }

        // --- Tab Switching Logic (Global Scope) ---
        // Activates the specified tab (report or history)
        function activateTab(tabName) {
             const tabButtonReport = document.getElementById('tabButtonReport');
             const tabButtonHistory = document.getElementById('tabButtonHistory');
             const tabPanelReport = document.getElementById('tabPanelReport');
             const tabPanelHistory = document.getElementById('tabPanelHistory');
             const historyContainer = document.getElementById('historyContainer'); // Need for history loading check

             // Check if tab elements exist
             if (!tabButtonReport || !tabButtonHistory || !tabPanelReport || !tabPanelHistory) {
                 console.warn("Elementos das abas não encontrados.");
                 return;
             }

             const isReportTab = tabName === 'report';

             // Update tab button classes and ARIA attributes
             tabButtonReport.classList.toggle('active', isReportTab);
             tabButtonReport.setAttribute('aria-selected', String(isReportTab));
             tabButtonHistory.classList.toggle('active', !isReportTab);
             tabButtonHistory.setAttribute('aria-selected', String(!isReportTab));

             // Show/hide tab panels
             tabPanelReport.classList.toggle('hidden', !isReportTab);
             tabPanelHistory.classList.toggle('hidden', isReportTab);

             // If switching to history tab and history is not yet loaded, load it
             if (!isReportTab && allHistoryItems.length === 0 && historyContainer && !historyContainer.innerHTML.includes('Carregando')) {
                 loadInitialHistory();
             } else if (!isReportTab) {
                 // If history is already in memory, ensure it's rendered correctly
                 applyFiltersAndRenderHistory();
             }
        }


        // --- Waits for DOM to Load Before Adding Listeners and Initializing ---
        // Use DOMContentLoaded to ensure all HTML elements are available before accessing them
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed. Initializing UI and listeners.");

            // --- Get DOM Elements (Inside DOMContentLoaded for safety) ---
            const apiKeyInput = document.getElementById('apiKey');
            const configApiKeyButton = document.getElementById('configApiKeyButton');
            const imageInput = document.getElementById('imageInput');
            const uploadButton = document.getElementById('uploadButton');
            const cameraButton = document.getElementById('cameraButton');
            const dropzone = document.getElementById('dropzone');
            const dropzoneContent = document.getElementById('dropzone-content');
            const cameraPreview = document.getElementById('cameraPreview');
            const cameraCanvas = document.getElementById('cameraCanvas');
            const captureButton = document.getElementById('captureButton');
            const stopCameraButton = document.getElementById('stopCameraButton');
            const themeToggle = document.getElementById('themeToggle');
            const searchInput = document.getElementById('searchInput');
            const applyFilters = document.getElementById('applyFilters');
            const loadMore = document.getElementById('loadMore');
            const listView = document.getElementById('listView');
            const gridView = document.getElementById('gridView');
            const categoryFilter = document.getElementById('categoryFilter');
            const sortOrder = document.getElementById('sortOrder');
            const fullScreenButton = document.getElementById('fullScreenButton');
            const closeModal = document.getElementById('closeModal');
            const reportModal = document.getElementById('reportModal');
            const printButton = document.getElementById('printButton');
            const whatsappButtonModal = document.getElementById('whatsappButton'); // WhatsApp button in modal
            const shareButtonModal = document.getElementById('shareButton'); // Share button in modal
            const downloadButtonModal = document.getElementById('downloadButton'); // Download button in modal
            const fontIncrease = document.getElementById('fontIncrease');
            const fontDecrease = document.getElementById('fontDecrease');
            const speakButton = document.getElementById('speakButton');
             const copyReportButton = document.getElementById('copyReportButton'); // New button in report controls
             const whatsappShareButton = document.getElementById('whatsappShareButton'); // New button in report controls
            const tabButtonReport = document.getElementById('tabButtonReport');
            const tabButtonHistory = document.getElementById('tabButtonHistory');
            const reportContent = document.getElementById('reportContent');
            const modalReportContent = document.getElementById('modalReportContent');
            const reportPlaceholder = document.getElementById('reportPlaceholder');
            const reportControls = document.getElementById('reportControls'); // Need for initial disabled state


            // --- Add Event Listeners ---

            // API Key Input & Button
            if (apiKeyInput) apiKeyInput.addEventListener('change', saveApiKey);
            if (configApiKeyButton && apiKeyInput) configApiKeyButton.addEventListener('click', () => { apiKeyInput.focus(); apiKeyInput.scrollIntoView({ behavior: 'smooth', block: 'center' }); });

            // Theme Toggle
            if (themeToggle) {
                themeToggle.addEventListener('click', () => {
                    const isDark = document.body.classList.toggle('dark-theme');
                    themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
                    localStorage.setItem('theme', isDark ? 'dark' : 'light');
                });
                // Apply theme on load if preference exists
                if (localStorage.getItem('theme') === 'dark') {
                    document.body.classList.add('dark-theme');
                    themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
                }
            }

            // Upload Button and Input
            if (uploadButton && imageInput) {
                uploadButton.addEventListener('click', () => imageInput.click());
                imageInput.addEventListener('change', (event) => {
                     // Check if files were selected and process the first one
                    if (event.target.files?.[0]) {
                        processFiles(event.target.files[0]);
                    }
                    event.target.value = null; // Clear the input to allow selecting the same file again
                });
            }

            // Dropzone (Drag & Drop)
            if (dropzone && dropzoneContent && imageInput) {
                dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('dragover'); });
                dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
                dropzone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropzone.classList.remove('dragover');
                    // Check if files were dropped and process the first one
                    if (e.dataTransfer?.files?.[0]) {
                         processFiles(e.dataTransfer.files[0]);
                    } else {
                         notify("Nenhum arquivo válido foi solto.", "info");
                    }
                });
                // Allow clicking the dropzone area (except buttons) to open file selector
                dropzoneContent.addEventListener('click', (e) => {
                    if (!e.target.closest('button') && !isProcessing) {
                        imageInput.click();
                    }
                });
            }

            // Camera Buttons & Capture
            if (cameraButton) cameraButton.addEventListener('click', startCamera);
            if (stopCameraButton) stopCameraButton.addEventListener('click', stopCamera);
            if (captureButton && cameraCanvas && cameraPreview) {
                 captureButton.addEventListener('click', async () => {
                    if (isProcessing) { notify("Aguarde análise.", "info"); return; }
                    // Check if camera stream is active and ready
                    if (!cameraStream || !cameraPreview.videoWidth || cameraPreview.videoWidth === 0 || cameraPreview.paused || cameraPreview.ended) {
                         notify("Câmera não pronta ou ativa.", "error"); stopCamera(); return;
                    }
                    const context = cameraCanvas.getContext('2d');
                    if (!context) { notify("Erro canvas.", "error"); return; }
                    // Set canvas dimensions to the video dimensions for accurate capture
                    cameraCanvas.width = cameraPreview.videoWidth;
                    cameraCanvas.height = cameraPreview.videoHeight;
                    console.log(`Capturando frame com ${cameraCanvas.width}x${cameraCanvas.height}`);
                    // Draw the current video frame onto the canvas
                    context.drawImage(cameraPreview, 0, 0, cameraCanvas.width, cameraCanvas.height);
                    stopCamera(); // Stop the camera *after* drawing the frame
                    showLoading("Processando captura..."); // Show loading for processing

                    // Convert the canvas content to a Blob (image file format)
                    cameraCanvas.toBlob(async (blob) => {
                        if (blob) {
                             // Create a File object from the Blob and process it
                            await processFiles(new File([blob],`capture-${Date.now()}.jpg`,{type:'image/jpeg'}));
                        } else {
                            // Handle error if Blob creation failed
                            notify("Falha ao criar imagem a partir da captura.", "error");
                            hideLoading();
                            isProcessing = false; // Reset processing flag
                        }
                    }, 'image/jpeg', 0.9); // Convert to JPEG with 90% quality
                });
            } else {
                console.warn("Elementos essenciais da câmera (botão, canvas, preview) não encontrados.");
            }

            // --- Report Controls Buttons ---
            if(fontIncrease && reportContent && modalReportContent) fontIncrease.addEventListener('click', () => { if (fontSize < 24) { fontSize += 1; reportContent.style.fontSize = `${fontSize}px`; modalReportContent.style.fontSize = `${fontSize}px`; } });
            if(fontDecrease && reportContent && modalReportContent) fontDecrease.addEventListener('click', () => { if (fontSize > 10) { fontSize -= 1; reportContent.style.fontSize = `${fontSize}px`; modalReportContent.style.fontSize = `${fontSize}px`; } });
            if(speakButton) speakButton.addEventListener('click', () => {
                if (!synth) { notify('Leitura de voz não suportada.', 'error'); return; }
                if (!currentResultText) { notify('Nada para ler.', 'info'); return; }

                if (synth.speaking) { // If currently speaking, stop
                    synth.cancel();
                    // Button state reset is handled by onend/onerror callbacks
                } else { // If not speaking, start
                    // Clean text for speaking (remove HTML, markdown)
                    const txt = currentResultText.replace(/<[^>]*>/g, ' ').replace(/[\*_#]+/g, ' ').replace(/\s\s+/g, ' ').trim();
                    if (!txt) { notify("Texto inválido para leitura.", "info"); return; }
                    utterance = new SpeechSynthesisUtterance(txt);
                    utterance.lang = 'pt-BR'; // Set language

                    // Set up event listeners for speak end and error
                    utterance.onerror = (e) => {
                        console.error('Speech Error:', e.error); notify(`Erro leitura: ${e.error}`, 'error');
                        if(speakButton){speakButton.innerHTML = '<i class="fas fa-volume-up"></i>'; speakButton.title = "Ler Relatório Atual"; speakButton.classList.remove('speaking');}
                    };
                    utterance.onend = () => {
                         if(speakButton){speakButton.innerHTML = '<i class="fas fa-volume-up"></i>'; speakButton.title = "Ler Relatório Atual"; speakButton.classList.remove('speaking');}
                    };

                    synth.speak(utterance); // Start speaking
                    // Update button UI
                    speakButton.innerHTML = '<i class="fas fa-stop-circle"></i>';
                    speakButton.title = "Parar Leitura";
                    speakButton.classList.add('speaking');
                }
             });
            // Stop speech if the user leaves the page
            window.addEventListener('beforeunload', () => { if (synth?.speaking) { synth.cancel(); } });

            // ** NEW: Copy Report Button **
            if(copyReportButton) {
                copyReportButton.addEventListener('click', async () => {
                    if (!currentResultText) {
                        notify('Nenhum relatório para copiar.', 'info');
                        return;
                    }
                    try {
                        // Clean text for plain text copy
                        const textToCopy = currentResultText
                            .replace(/<br\s*\/?>/gi, '\n') // Convert HTML breaks to newlines
                            .replace(/<[^>]*>/g, '')     // Remove other HTML tags (strong, em, etc.)
                            .replace(/[\*_]+/g, '')      // Remove Markdown formatting characters (*, _)
                            .trim();
                        // Add a disclaimer at the end
                        const disclaimer = "\n\nAtenção: Esta análise é preliminar e não substitui uma consulta veterinária. Consulte sempre um profissional.";

                        // Use Clipboard API to copy text
                        await navigator.clipboard.writeText(textToCopy + disclaimer);
                        notify('Relatório copiado para a área de transferência!', 'success');
                    } catch (err) {
                        console.error('Falha ao copiar relatório:', err);
                        notify('Falha ao copiar relatório.', 'error');
                    }
                });
            } else { console.warn("Botão de copiar relatório não encontrado."); }

             // ** NEW: WhatsApp Share Button (Report Controls) **
             if(whatsappShareButton) {
                 whatsappShareButton.addEventListener('click', () => {
                    if (!currentResultText) {
                        notify('Nenhum relatório para compartilhar.', 'info');
                        return;
                    }
                     // Clean text for WhatsApp plain text share
                    const textToShare = currentResultText
                        .replace(/<br\s*\/?>/gi, '\n') // Convert HTML breaks to newlines
                        .replace(/<[^>]*>/g, '')     // Remove other HTML tags
                        .replace(/[\*_]+/g, '')      // Remove Markdown characters
                        .trim();
                     // Add disclaimer formatted for WhatsApp (using markdown *bold*)
                    const disclaimer = "\n\n*Atenção:* Esta análise é preliminar e não substitui uma consulta veterinária. Consulte sempre um profissional.";
                    const generatedBy = "\n_Gerado por Análise de Pets IA_";

                    // Construct the WhatsApp message text
                    const fullMessage = `*Análise de Pet (IA):*\n\n${textToShare}${disclaimer}${generatedBy}`;

                    // Encode the message for the URL
                    const message = encodeURIComponent(fullMessage);

                    // Open the WhatsApp share URL in a new tab
                    // Note: Sharing images directly via wa.me link is not possible.
                    window.open(`https://wa.me/?text=${message}`, '_blank');
                 });
             } else { console.warn("Botão de compartilhar WhatsApp (controles) não encontrado."); }


            // --- Modal Handling & Actions ---
            if(fullScreenButton && reportModal && modalReportContent) fullScreenButton.addEventListener('click', () => { if (lastSuccessfulAnalysisHTML) { modalReportContent.innerHTML = lastSuccessfulAnalysisHTML; reportModal.style.display = 'flex'; modalReportContent.style.fontSize = `${fontSize}px`; } else { notify('Nada para tela cheia.', 'info'); } });
            if(closeModal && reportModal) closeModal.addEventListener('click', () => { reportModal.style.display = 'none'; if (synth?.speaking) synth.cancel(); });
            if(reportModal) reportModal.addEventListener('click', (e) => { if (e.target === reportModal) { reportModal.style.display = 'none'; if (synth?.speaking) synth.cancel(); } });

            // Modal Print Button
            if(printButton && lastSuccessfulAnalysisHTML) printButton.addEventListener('click', () => {
                if (!lastSuccessfulAnalysisHTML) return notify("Nada para imprimir.", "info");
                const printWindow = window.open('', '_blank');
                if (!printWindow) { notify("Permita pop-ups para imprimir.", "error"); return; }
                 // Write the HTML structure for the print page
                 printWindow.document.write(`
                 <!DOCTYPE html><html lang="pt-BR"><head><meta charset="UTF-8"><title>Análise de Pet IA</title>
                 <style>
                     body{font-family:sans-serif;line-height:1.5;padding:20px;color:#333;}
                     img{max-width:250px;max-height:250px;display:block;margin:0 auto 20px auto;border:1px solid #ccc;object-fit:contain;}
                     h2{font-size:1.4rem;border-bottom:1px solid #eee;padding-bottom:8px;margin-bottom:20px;text-align:center;}
                     strong{font-weight:bold;}em{font-style:italic;}
                     p.disclaimer{background-color:#fff3cd;border:1px solid #ffeeba;padding:10px;margin-bottom:15px;color:#856404;border-radius:4px;font-size:.9rem;}
                     /* Hide controls and file header in print */
                     #reportControls, .report-file-header { display: none !important; }
                     /* Print-specific adjustments */
                     @media print{
                         body{padding:10px;}
                         img{max-width:70%;} /* Allow image to be slightly larger in print */
                         p.disclaimer{background-color:#ffffcc!important; border-color:#ffeeaa!important;} /* Ensure background prints */
                     }
                 </style>
                 </head><body><h2>Relatório de Análise de Pet - IA</h2>
                 ${currentImageBase64 ? '<img src="data:image/jpeg;base64,'+currentImageBase64+'" alt="Imagem do Pet Analisada">' : ''}
                 ${lastSuccessfulAnalysisHTML.replace(REPORT_DISCLAIMER_HTML, '<p class="disclaimer"><strong>Atenção:</strong> Análise preliminar por IA. Não substitui consulta veterinária.</p>')}
                 <script>
                     // Use setTimeout to ensure content is rendered before printing
                     setTimeout(() => {
                         window.print();
                         window.close(); // Close the print window after printing
                     }, 500); // Small delay might help
                 <\/script>
                 </body></html>
                 `);
                printWindow.document.close(); // Close the document stream
            });

            // Modal WhatsApp Button (Shares TEXT only)
            if(whatsappButtonModal) whatsappButtonModal.addEventListener('click', () => {
                 if (!currentResultText) return notify("Nada para compartilhar.", "info");
                 // Clean text for WhatsApp plain text share
                const textToShare = currentResultText
                    .replace(/<br\s*\/?>/gi, '\n')
                    .replace(/<[^>]*>/g, '')
                    .replace(/[\*_]+/g, '')
                    .trim();
                 // Add disclaimer formatted for WhatsApp
                const disclaimer = "\n\n*Atenção:* Esta análise é preliminar e não substitui uma consulta veterinária. Consulte sempre um profissional.";
                 const generatedBy = "\n_Gerado por Análise de Pets IA_";

                const fullMessage = `*Análise de Pet (IA):*\n\n${textToShare}${disclaimer}${generatedBy}`;
                const message = encodeURIComponent(fullMessage);
                window.open(`https://wa.me/?text=${message}`, '_blank');
            });

            // Modal Share Button (Uses Web Share API or Clipboard fallback)
            if(shareButtonModal) shareButtonModal.addEventListener('click', async () => {
                 if (!currentResultText) return notify("Nada para compartilhar.", "info");
                 // Prepare text for sharing (clean + disclaimer)
                 const textToShare = currentResultText
                    .replace(/<br\s*\/?>/gi, '\n')
                    .replace(/<[^>]*>/g, '')
                    .replace(/[\*_]+/g, '')
                    .trim();
                 const disclaimer = "\n\nAtenção: Esta análise é preliminar e não substitui uma consulta veterinária. Consulte sempre um profissional.";
                 const shareText = `Análise de Pet (IA):\n\n${textToShare}${disclaimer}`;

                 const shareData = {
                     title: 'Análise de Pet - IA',
                     text: shareText,
                     // Optional: url: window.location.href // Share the page URL
                 };

                 try {
                     // Use the Web Share API if available (mobile browsers often support this)
                     if (navigator.share) {
                          await navigator.share(shareData);
                          console.log('Conteúdo compartilhado com sucesso via Web Share API.');
                     } else if (navigator.clipboard) { // Fallback: Copy to clipboard if Share API not available
                          await navigator.clipboard.writeText(shareData.text);
                          notify('Relatório copiado para a área de transferência!', 'success');
                     } else {
                          // Fallback for older browsers without Clipboard API
                          notify('Compartilhamento não suportado neste navegador.', 'info');
                     }
                 } catch (err) {
                     // Ignore AbortError (user cancelled sharing)
                     if (err.name !== 'AbortError') {
                         console.error('Erro ao compartilhar:', err);
                         notify(`Erro ao compartilhar: ${err.message}`, 'error');
                     }
                 }
             });

            // Modal Download PDF Button
            if(downloadButtonModal) downloadButtonModal.addEventListener('click', () => {
                if (!currentResultText) return notify("Nada para baixar.", "info");
                try {
                    const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                    doc.setFont('helvetica', 'normal');
                    const margin = 15;
                    const contentWidth = doc.internal.pageSize.width - 2 * margin;
                    let currentY = margin;

                    // Title
                    doc.setFontSize(16);
                    doc.setFont('helvetica', 'bold');
                    doc.text('Análise de Pet - IA', doc.internal.pageSize.width / 2, currentY, { align: 'center' });
                    currentY += 10;

                    // Image (if exists)
                    if (currentImageBase64) {
                         try {
                             const imgData = `data:image/jpeg;base64,${currentImageBase64}`;
                             const imgProps = doc.getImageProperties(imgData);
                             const aspectRatio = imgProps.width / imgProps.height;
                             let imgWidth = 80;
                             let imgHeight = imgWidth / aspectRatio;
                             const maxHeight = 80;
                             if (imgHeight > maxHeight) { imgHeight = maxHeight; imgWidth = imgHeight * aspectRatio; }
                             const imgX = (doc.internal.pageSize.width - imgWidth) / 2;
                             if (currentY + imgHeight > doc.internal.pageSize.height - margin) { doc.addPage(); currentY = margin; }
                             doc.addImage(imgData, 'JPEG', imgX, currentY, imgWidth, imgHeight);
                             currentY += imgHeight + 10;
                         } catch (imgError) {
                             console.error("Erro ao adicionar imagem ao PDF:", imgError);
                             currentY += 5;
                         }
                    }

                    // Disclaimer
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'italic');
                    doc.setTextColor(100, 100, 100);
                    const disclaimerTextPdf = "Atenção: Esta é uma análise preliminar gerada por IA e NÃO substitui a avaliação ou diagnóstico de um médico veterinário qualificado. Sempre consulte um profissional.";
                    const disclaimerLines = doc.splitTextToSize(disclaimerTextPdf, contentWidth);
                    disclaimerLines.forEach(line => {
                        if (currentY + 4 > doc.internal.pageSize.height - margin) { doc.addPage(); currentY = margin; }
                        doc.text(line, margin, currentY);
                        currentY += 4;
                    });
                    doc.setTextColor(0, 0, 0);
                    currentY += 6;

                    // Analysis Text
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    // Clean text for PDF (remove HTML, Markdown, and the AI's disclaimer if present)
                    let pdfText = currentResultText
                        .replace(/<br\s*\/?>/gi, '\n')
                        .replace(/<[^>]*>/g, '')
                        .replace(/[\*_]+/g, '')
                         .replace(/Lembre-se: Sou uma IA.*profissional\./i, '') // Remove AI's final disclaimer
                        .replace(/\n\s*\n/g, '\n')
                        .replace(/ /g, ' ')
                        .trim();

                    const textLines = doc.splitTextToSize(pdfText, contentWidth);
                    textLines.forEach(line => {
                        if (currentY + 5 > doc.internal.pageSize.height - margin) { doc.addPage(); currentY = margin; }
                        doc.text(line, margin, currentY);
                        currentY += 5;
                    });

                    // Save the PDF file
                    doc.save(`AnalisePetIA_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}.pdf`);
                    notify('PDF da análise gerado!', 'success');
                } catch (error) {
                    console.error("Erro ao gerar PDF com jsPDF:", error);
                    notify(`Erro ao gerar PDF: ${error.message || error}`, 'error');
                }
             });


            // --- History Filters/Pagination/View Listeners ---
            if(applyFilters) applyFilters.addEventListener('click', applyFiltersAndRenderHistory);
            if(searchInput) {
                searchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') applyFiltersAndRenderHistory(); });
                searchInput.addEventListener('search', applyFiltersAndRenderHistory); // Handles clear 'x' button
                // Optional: Filter dynamically as user types (can be slow for large history)
                // searchInput.addEventListener('input', applyFiltersAndRenderHistory);
            }
            if(loadMore) loadMore.addEventListener('click', () => { if (!loadMore.disabled) { currentPage++; renderHistory(); } });
            if(listView) listView.addEventListener('click', () => { if (viewMode !== 'list') { viewMode = 'list'; currentPage = 1; renderHistory(); } });
            if(gridView) gridView.addEventListener('click', () => { if (viewMode !== 'grid') { viewMode = 'grid'; currentPage = 1; renderHistory(); } });
            if(categoryFilter) categoryFilter.addEventListener('change', applyFiltersAndRenderHistory);
            if(sortOrder) sortOrder.addEventListener('change', applyFiltersAndRenderHistory);

            // --- Tab Switching Logic ---
            if(tabButtonReport) tabButtonReport.addEventListener('click', () => activateTab('report'));
            if(tabButtonHistory) tabButtonHistory.addEventListener('click', () => activateTab('history'));

            // --- Initial UI State ---
            // Set initial font size for report content areas
            if (reportContent) reportContent.style.fontSize = `${fontSize}px`;
            if (modalReportContent) modalReportContent.style.fontSize = `${fontSize}px`;

            // Show placeholder text if report content is empty initially
            if (reportPlaceholder && reportContent && !reportContent.innerHTML.trim() && !isProcessing) {
                reportPlaceholder.classList.remove('hidden');
            } else if (reportPlaceholder) {
                 reportPlaceholder.classList.add('hidden');
            }

            // Ensure report controls are disabled initially
            if(reportControls) {
                 // Disable all buttons within reportControls
                 reportControls.querySelectorAll('button').forEach(button => {
                     button.disabled = true;
                 });
                 // Controls are hidden by default in HTML, will be shown by processFiles/viewAnalysis
            } else {
                console.warn("Report controls container not found.");
            }


            // Database opening is asynchronous. loadInitialHistory and loadApiKey are called in db.onsuccess.
            // No need to call them directly here inside DOMContentLoaded.

            console.log("Inicialização do DOM e configuração de listeners concluída.");

        }); // --- END OF DOMContentLoaded ---

    </script>

</body>
</html>
