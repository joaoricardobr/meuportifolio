<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gravador Inteligente Pro v9 - Unificado</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Google Platform Library - Necessário para Google Sign-In e Calendar API -->
    <script src="https://apis.google.com/js/api.js" defer></script>

    <style>
        /* --- Início do CSS Embutido --- */
        :root {
            --primary-color: #3498DB;
            --secondary-color: #7F8C8D;
            --accent-color: #1ABC9C;
            --success-color: #2ECC71;
            --danger-color: #E74C3C;
            --warning-color: #F1C40F;
            --info-color: #5DADE2;
            --purple-color: #8E44AD;
            --google-color: #DB4437;
            --light-bg: #f8f9fa; /* Ligeiramente mais claro */
            --white-bg: #FFFFFF;
            --text-dark: #212529; /* Mais escuro */
            --text-light: #f8f9fa;
            --border-color: #dee2e6;
            --shadow-color: rgba(52, 152, 219, 0.15);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        html { height: 100%; } /* Garante que body pode usar 100% */

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--light-bg);
            color: var(--text-dark);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 10px;
            overscroll-behavior: contain;
            font-size: 15px;
            line-height: 1.5;
        }

        #app-shell {
            width: 100%;
            max-width: 400px;
            height: calc(100vh - 20px);
            max-height: 750px; /* Limite máximo de altura */
            background-color: var(--white-bg);
            border-radius: 20px;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* --- Top Bar --- */
        #top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px; /* Um pouco mais compacto */
            background-color: var(--white-bg);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative; /* Para z-index se necessário */
            z-index: 10;
        }
        .icon-button {
            background: none; border: none;
            font-size: 1.25em; /* Ligeiramente menor */
            color: var(--primary-color);
            cursor: pointer;
            padding: 6px; /* Menor padding */
            width: 38px; height: 38px;
            line-height: 1; text-align: center;
            border-radius: 50%;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .icon-button:hover:not(:disabled) { background-color: rgba(0,0,0,0.05); }
        .icon-button:disabled { color: #adb5bd; cursor: not-allowed; background-color: transparent;}
        #back-button { display: none; } /* Escondido inicialmente */
        .top-bar-buttons { display: flex; align-items: center; gap: 3px; } /* Menor gap */
        #app-title {
            font-size: 1.05em; font-weight: 600; color: var(--secondary-color);
            margin: 0 8px; white-space: nowrap; overflow: hidden;
            text-overflow: ellipsis; flex-grow: 1; text-align: center;
        }
        #google-auth-button i { color: var(--google-color); }
        #google-auth-button.logged-in i { color: var(--success-color); } /* Indica login */

        /* --- Main Content & Views --- */
        #main-content {
            flex-grow: 1;
            overflow: hidden; /* Essencial para as views não vazarem */
            position: relative; /* Contexto para as views absolutas */
        }
        .view {
            position: absolute; inset: 0; /* Ocupa todo o espaço */
            background-color: var(--white-bg);
            transition: transform 0.35s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.35s ease; /* Added opacity transition */
            overflow-y: auto; /* Permite scroll se conteúdo exceder */
            display: flex;
            flex-direction: column;
            opacity: 0; /* Escondido por padrão */
            transform: translateX(100%); /* Fora da tela */
            z-index: 1;
            visibility: hidden; /* Hide when not active */
        }
        .view.active-view {
            opacity: 1;
            transform: translateX(0);
            z-index: 2; /* View ativa fica na frente */
            visibility: visible; /* Show when active */
        }
        /* No need for specific #recording-view transform here anymore */

        /* Navegação entre views (controlada por JS/classe) */
        #app-shell.show-list #recording-view {
            transform: translateX(-100%);
            opacity: 0;
            z-index: 1;
            visibility: hidden;
         }
        #app-shell.show-list #list-view {
            transform: translateX(0);
            opacity: 1;
            z-index: 2;
            visibility: visible;
        }
         /* Initial state for recording view needs to be visible */
        #recording-view {
             opacity: 1;
             transform: translateX(0);
             visibility: visible;
             z-index: 2; /* Start with recording view on top */
        }
         #list-view {
            /* Start list view off-screen */
             transform: translateX(100%);
             opacity: 0;
             visibility: hidden;
             z-index: 1;
         }


        /* --- Recording View Otimizada --- */
        #recording-view {
            justify-content: center; /* Centraliza o conteúdo principal */
            align-items: center;
            text-align: center;
            padding: 0; /* SEM padding interno geral */
            background: var(--white-bg); /* Fundo simples */
        }
        .recording-area {
            /* Área para o ícone e timer, centralizada */
            flex-grow: 1; /* Tenta ocupar espaço */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%; /* Garante largura total */
            margin-top: -5%; /* Puxa um pouco para cima do centro exato */
            padding: 10px; /* Add some padding inside the area */
        }
        #recording-icon-wrapper {
            width: 120px; height: 120px; /* Um pouco maior */
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            margin-bottom: 25px;
            position: relative;
            background-color: #fff;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border: 4px solid var(--light-bg);
            flex-shrink: 0; /* Prevent shrinking */
        }
        #recording-icon { font-size: 3.2em; z-index: 2; transition: color 0.3s ease; }
        #recording-icon-wrapper::before { /* Animação de pulso */
            content: ''; position: absolute; left: 50%; top: 50%;
            width: 90%; height: 90%; border-radius: 50%;
            background-color: var(--accent-color); opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
            animation: idle-wave 2.5s infinite ease-out;
            z-index: 1;
        }
        /* Estados do ícone e animação */
        #recording-icon.state-idle { color: var(--success-color); }
        #recording-icon.state-idle + #recording-icon-wrapper::before { animation: idle-wave 2.5s infinite ease-out; background-color: var(--success-color); opacity: 0.15; } /* Make idle wave visible */
        #recording-icon.state-recording { color: var(--danger-color); }
        #recording-icon.state-recording + #recording-icon-wrapper::before { animation: recording-wave 1.5s infinite ease-out; background-color: var(--danger-color); opacity: 0.4; } /* Make recording wave visible */
        #recording-icon.state-paused { color: var(--warning-color); }
        #recording-icon.state-paused + #recording-icon-wrapper::before,
        #recording-icon.state-processing + #recording-icon-wrapper::before,
        #recording-icon.state-analyzing + #recording-icon-wrapper::before { animation: none; opacity: 0; }
        #recording-icon.state-processing { color: var(--info-color); } /* Cor para processando */
        #recording-icon.state-analyzing { color: var(--purple-color); } /* Cor para analisando */

        @keyframes recording-wave { 0% { transform: translate(-50%, -50%) scale(0.9); opacity: 0.4; } 70% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.1; } 100% { transform: translate(-50%, -50%) scale(1.4); opacity: 0; } }
        @keyframes idle-wave { 0% { transform: translate(-50%, -50%) scale(0.95); opacity: 0.15; } 50% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.05; } 100% { transform: translate(-50%, -50%) scale(0.95); opacity: 0.15; } }

        #timer-recording {
            font-size: 3.2em; font-weight: 300; color: var(--text-dark);
            letter-spacing: 1.5px; margin-bottom: 20px;
            font-variant-numeric: tabular-nums;
             flex-shrink: 0; /* Prevent shrinking */
        }
        .recording-controls {
            display: flex;
            justify-content: space-around; /* Espaçar botões */
            align-items: center;
            width: 100%;
            padding: 15px 20px; /* Padding para os controles */
            background-color: rgba(255, 255, 255, 0.8); /* Fundo leve para destacar */
            border-top: 1px solid var(--border-color);
            flex-shrink: 0; /* Não encolher */
             /* Position absolute removed, let it be part of flex flow */
        }
        .recording-controls button {
            border: none; border-radius: 50%;
            cursor: pointer;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s;
            font-size: 1em; /* Tamanho base do ícone dentro */
             width: 60px; /* Slightly smaller secondary buttons */
             height: 60px;
        }
        .recording-controls button span { font-size: 0.7em; margin-top: 4px; color: var(--secondary-color); }
        .recording-controls button:disabled { opacity: 0.5; cursor: not-allowed; background-color: transparent !important; }
        .recording-controls button:active:not(:disabled) { transform: scale(0.95); }

        .control-main { /* Botão central (Gravar/Pausar) */
            width: 70px; height: 70px;
            color: white; font-size: 1.9em;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .control-main.state-idle { background-color: var(--success-color); }
        .control-main.state-recording { background-color: var(--warning-color); color: var(--text-dark); }
        .control-main.state-paused { background-color: var(--info-color); }
        .control-main .fa-play { margin-left: 3px; } /* Ajuste fino ícone play */

        .control-secondary { /* Botões laterais (Descartar/Parar) */
             width: 55px; height: 55px; /* Explicit size */
            background: none; color: var(--secondary-color);
            font-size: 1.1em; /* Ícone um pouco maior */
        }
        .control-secondary:hover:not(:disabled) { background-color: rgba(0,0,0,0.05); }
        #discardButton i { color: var(--danger-color); }
        #stopButton i { color: var(--danger-color); } /* Usar cor de perigo para parar */
        #discardButton span, #stopButton span { font-weight: 500; }

        /* --- List View (Histórico e Texto) --- */
        #list-view {
            padding: 15px;
            justify-content: flex-start; /* Alinhar conteúdo no topo */
        }
        #list-view h2 {
            font-size: 1.1em; margin-bottom: 10px; color: var(--primary-color);
            padding-bottom: 5px; border-bottom: 1px solid #eee;
            margin-top: 15px; /* Espaço acima dos títulos */
            flex-shrink: 0;
        }
        #list-view h2:first-of-type { margin-top: 0; }

        #text-action-area {
            background: #fdfdfd; padding: 15px;
            border-radius: 8px; border: 1px solid var(--border-color);
            margin-bottom: 20px;
             flex-shrink: 0; /* Prevent shrinking */
        }
        #transcriptionTextarea {
            width: 100%; min-height: 120px; max-height: 200px; /* Added max-height */
             padding: 12px;
            border: 1px solid var(--border-color); border-radius: 8px;
            font-size: 1em; line-height: 1.6; margin-bottom: 12px;
            resize: vertical; transition: background-color 0.2s;
        }
        #transcriptionTextarea:read-only { background-color: var(--light-bg); }
        .text-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .text-actions button { /* Estilo unificado para botões de ação */
            padding: 8px 15px; font-size: 0.85em; border-radius: 20px;
            border: none; cursor: pointer;
            transition: all 0.2s ease;
            color: white; margin-bottom: 5px; flex-shrink: 0;
            background-color: var(--primary-color); /* Cor padrão */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .text-actions button:hover:not(:disabled) { opacity: 0.9; box-shadow: 0 3px 8px rgba(0,0,0,0.15);}
        .text-actions button:active:not(:disabled) { transform: scale(0.97); }
        .text-actions button:disabled { opacity: 0.6; cursor: not-allowed; background-color: var(--secondary-color); box-shadow: none;}
        .text-actions button i { margin-right: 6px; }
        /* Cores específicas */
        #manualScheduleButton { background-color: var(--purple-color); }
        #whatsappButton { background-color: var(--success-color); }
        #copyTextButton { background-color: var(--info-color); }


        /* --- History List --- */
        #historyList {
            list-style: none; padding: 0;
            flex-grow: 1; /* Allow history list to take remaining space */
            overflow-y: auto; margin-top: 5px;
            border-top: 1px solid var(--border-color);
            padding-top: 10px;
        }
        #historyList li {
            padding: 12px 10px; border-bottom: 1px solid #f0f0f0;
            margin-bottom: 5px; background-color: var(--white-bg);
            display: flex; flex-wrap: wrap; align-items: center; gap: 10px;
            font-size: 0.9em; transition: background-color 0.2s ease;
            border-radius: 5px;
        }
        #historyList li:hover { background-color: #fafdff; }
        .history-placeholder { text-align: center; color: var(--secondary-color); padding: 20px; background: none; border: none; }
        .history-info { flex-grow: 1; color: var(--secondary-color); display: flex; flex-direction: column; min-width: 100px; overflow: hidden;} /* Added overflow */
        .history-info .item-type { font-size: 0.7em; font-weight: bold; text-transform: uppercase; margin-bottom: 3px; border-radius: 3px; padding: 2px 5px; color: white; display: inline-block; width: fit-content;}
        .history-info .item-type.type-audio { background-color: var(--info-color); }
        .history-info .item-type.type-text { background-color: var(--purple-color); }
        .history-info .item-type.type-image { background-color: var(--warning-color); }
        .history-info .item-type.type-document { background-color: var(--accent-color); }
        .history-info .item-type.type-video { background-color: var(--danger-color); } /* Tipo vídeo */
        .history-info .date-time { font-size: 0.85em; color: var(--text-dark); font-weight: 500; }
        .history-info .item-name { font-size: 0.8em; color: #6c757d; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; /* Removed max-width */ } /* Nome do arquivo */
        .history-transcription {
            width: 100%; font-size: 0.9em; color: #495057;
            margin-top: 8px; padding-top: 8px;
            border-top: 1px dashed #eee;
            max-height: 60px; /* Limita altura da prévia */
            overflow: hidden;
            text-overflow: ellipsis;
             display: -webkit-box; /* Permite limitar por linhas */
            -webkit-line-clamp: 3; /* Mostrar no máximo 3 linhas */
            -webkit-box-orient: vertical;
            word-break: break-word; /* Break long words if needed */
        }
        .history-actions { display: flex; gap: 8px; flex-wrap: nowrap; margin-left: auto; flex-shrink: 0;} /* nowrap prevents wrapping */
        .history-actions button { /* Estilo unificado botões histórico */
            padding: 6px 10px; font-size: 0.8em; cursor: pointer;
            border-radius: 15px; border: none; color: white; flex-shrink: 0;
            transition: all 0.2s;
            background-color: var(--secondary-color); /* Cor padrão */
        }
        .history-actions button:hover:not(:disabled) { opacity: 0.9; }
        .history-actions button:active:not(:disabled) { transform: scale(0.95); }
        .history-actions button i { margin-right: 4px; font-size: 1.1em; /* Slightly larger icon */ }
        /* Cores específicas histórico */
        .play-history-btn { background-color: var(--primary-color); }
        .load-history-btn { background-color: var(--accent-color); }
        .schedule-history-btn { background-color: var(--purple-color); } /* Botão Re-agendar */
        .delete-history-btn { background-color: var(--danger-color); }

        /* --- Status Bar --- */
        #status-bar {
            padding: 8px 15px; font-size: 0.8em; text-align: left; /* Alinhado à esquerda */
            border-top: 1px solid var(--border-color); flex-shrink: 0;
            background-color: var(--light-bg);
            display: flex; justify-content: space-between; align-items: center; /* Espaço para status auth */
            transition: background-color 0.3s, color 0.3s;
            min-height: 35px; /* Ensure minimum height */
        }
        #status-message { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 10px;}
        #auth-status { font-size: 0.9em; color: var(--secondary-color); font-style: italic; flex-shrink: 0; white-space: nowrap; }
        /* Classes de status */
        #status-bar.status-success { color: var(--success-color); background-color: #d4edda; font-weight: 500; }
        #status-bar.status-error { color: var(--danger-color); background-color: #f8d7da; font-weight: 500; }
        #status-bar.status-loading { color: var(--info-color); background-color: #d1ecf1; font-weight: 500; }
        #status-bar.status-warning { color: var(--warning-color); background-color: #fff3cd; font-weight: 500; }


        /* --- Modal --- */
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); animation: fadeIn 0.3s ease; }
        .modal-content { background-color: var(--white-bg); margin: 10% auto; padding: 25px 30px; border: none; width: 90%; max-width: 500px; border-radius: 12px; position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.2); animation: slideIn 0.3s ease; }
        .modal-close-button { color: #aaa; position: absolute; top: 12px; right: 15px; font-size: 26px; font-weight: bold; cursor: pointer; line-height: 1; }
        .modal-close-button:hover, .modal-close-button:focus { color: var(--danger-color); }
        .modal h2 { margin-top: 0; margin-bottom: 15px; color: var(--primary-color); text-align: center; font-size: 1.3em; }
        .modal p { margin-bottom: 20px; line-height: 1.5; text-align: center; font-size: 0.95em; color: var(--secondary-color);}
        .modal .form-group { margin-bottom: 15px; }
        .modal .form-group label { display: block; margin-bottom: 6px; font-weight: 500; color: var(--secondary-color); font-size: 0.9em; }
        .modal .form-group input[type="password"], .modal .form-group input[type="text"], .modal .form-group select { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1em; }
        .modal .form-group small { font-size: 0.8em; color: #6c757d; margin-top: 4px; display: block; }
        .modal .button-primary { padding: 12px 20px; background: linear-gradient(to right, var(--primary-color), #2980B9); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1em; width: 100%; margin-top: 10px; transition: opacity 0.2s ease, transform 0.1s ease; display: block; font-weight: 500; }
        .modal .button-primary:hover { opacity: 0.9; }
        .modal .button-primary:active { transform: scale(0.98); }
        .modal-status { margin-top: 15px; text-align: center; font-size: 0.9em; min-height: 1.2em; font-weight: 500; }
        .modal-status.status-error { color: var(--danger-color); }
        .modal-status.status-success { color: var(--success-color); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }


        /* --- Dark Mode --- */
        body.dark-mode {
            background-color: #212529; color: var(--text-light);
        }
        body.dark-mode #app-shell { background-color: #343a40; box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4); }
        body.dark-mode #top-bar { background-color: #343a40; border-bottom: 1px solid #495057; }
        body.dark-mode #app-title { color: #e9ecef; }
        body.dark-mode .icon-button { color: var(--accent-color); }
        body.dark-mode .icon-button:hover:not(:disabled) { background-color: rgba(255,255,255,0.1); }
        body.dark-mode .icon-button:disabled { color: #6c757d; }
        body.dark-mode #recording-view { background: #343a40; }
        body.dark-mode #recording-icon-wrapper { background-color: #495057; border: 4px solid #212529; }
        body.dark-mode #timer-recording { color: var(--text-light); }
        body.dark-mode .recording-controls { background-color: rgba(40, 40, 40, 0.8); border-top: 1px solid #495057; }
        body.dark-mode .control-secondary { color: #adb5bd; }
        body.dark-mode .control-secondary:hover:not(:disabled) { background-color: rgba(255,255,255,0.08); }
        body.dark-mode #discardButton i, body.dark-mode #stopButton i { color: #ff6b6b; } /* Cor de perigo mais clara */
        body.dark-mode #discardButton span, body.dark-mode #stopButton span { color: #adb5bd; }
        body.dark-mode .control-main.state-recording { background-color: var(--warning-color); color: #343a40;} /* Ensure contrast on pause/rec button */
        body.dark-mode #list-view { background-color: #343a40; }
        body.dark-mode #list-view h2 { color: var(--accent-color); border-bottom: 1px solid #495057; }
        body.dark-mode #text-action-area { background: #495057; border: 1px solid #212529; }
        body.dark-mode #transcriptionTextarea { background-color: #212529; color: var(--text-light); border: 1px solid #6c757d; }
        body.dark-mode #transcriptionTextarea:read-only { background-color: #3a4148; }
        body.dark-mode #historyList { border-top: 1px solid #495057; }
        body.dark-mode #historyList li { background-color: #495057; border-bottom: 1px solid #5a6268; } /* Slightly adjusted li background */
        body.dark-mode #historyList li:hover { background-color: #5a6268; }
        body.dark-mode .history-info .date-time { color: var(--text-light); }
        body.dark-mode .history-info .item-name { color: #adb5bd; }
        body.dark-mode .history-transcription { color: #ced4da; border-top: 1px dashed #5a6268; }
        body.dark-mode #status-bar { background-color: #212529; border-top: 1px solid #495057; color: var(--text-light);}
        body.dark-mode #status-bar.status-success { background-color: #1a3a25; color: #a7d7b9; }
        body.dark-mode #status-bar.status-error { background-color: #4d1a21; color: #f1b0b7; }
        body.dark-mode #status-bar.status-loading { background-color: #113c45; color: #a8dde7; }
        body.dark-mode #status-bar.status-warning { background-color: #5c4510; color: #f8e6aa; }
        body.dark-mode #auth-status { color: #adb5bd; }
        body.dark-mode .modal-content { background-color: #343a40; color: var(--text-light); }
        body.dark-mode .modal-close-button { color: #adb5bd; }
        body.dark-mode .modal h2 { color: var(--accent-color); }
        body.dark-mode .modal p { color: #adb5bd; }
        body.dark-mode .modal .form-group label { color: #ced4da; }
        body.dark-mode .modal .form-group input[type="password"],
        body.dark-mode .modal .form-group input[type="text"],
        body.dark-mode .modal .form-group select { background-color: #212529; color: var(--text-light); border: 1px solid #6c757d; }
        body.dark-mode .modal .form-group small { color: #adb5bd; }
        body.dark-mode .modal .button-primary { background: linear-gradient(to right, var(--accent-color), #16A085); }
        /* --- Fim do CSS Embutido --- */
    </style>
</head>
<body>
    <div id="app-shell">
        <div id="top-bar">
            <button id="back-button" class="icon-button" title="Voltar"><i class="fas fa-arrow-left"></i></button>
            <h1 id="app-title">Gravar</h1>
            <div class="top-bar-buttons">
                <button id="attachButton" class="icon-button" title="Anexar Arquivo"><i class="fas fa-paperclip"></i></button>
                <button id="themeToggleButton" class="icon-button theme-toggle" title="Alternar Tema"><i class="fas fa-moon"></i></button>
                <button id="historyButton" class="icon-button" title="Histórico"><i class="fas fa-list-ul"></i></button>
                <button id="settingsButton" class="icon-button" title="Configurações"><i class="fas fa-cog"></i></button>
                <!-- Botão de Login/Logout Google -->
                 <button id="google-auth-button" class="icon-button" title="Login Google"><i class="fab fa-google"></i></button>
            </div>
        </div>

        <div id="main-content">
            <!-- Tela de Gravação Otimizada -->
            <div id="recording-view" class="view active-view"> <!-- Starts active -->
                <div class="recording-area">
                    <div id="recording-icon-wrapper">
                        <i id="recording-icon" class="fas fa-microphone state-idle"></i>
                    </div>
                    <div id="timer-recording">00:00</div>
                </div>
                <div class="recording-controls">
                    <button id="discardButton" class="control-secondary" title="Descartar" disabled>
                        <i class="fas fa-times"></i> <span>Descartar</span>
                    </button>
                    <button id="recordPauseResumeButton" class="control-main state-idle" title="Gravar">
                        <i class="fas fa-microphone"></i>
                    </button>
                    <button id="stopButton" class="control-secondary" title="Parar" disabled>
                        <i class="fas fa-stop"></i> <span>Parar</span>
                    </button>
                </div>
            </div>

            <!-- Tela de Lista/Histórico -->
            <div id="list-view" class="view"> <!-- Starts hidden -->
                <div id="text-action-area">
                    <h2>Transcrição / Texto</h2>
                    <textarea id="transcriptionTextarea" placeholder="A transcrição aparecerá aqui ou digite/cole texto..."></textarea>
                    <div class="text-actions">
                        <!-- Botão de agendamento manual (pode coexistir com o automático) -->
                        <button id="manualScheduleButton" title="Tentar Agendar Texto Atual" disabled>
                            <i class="far fa-calendar-plus"></i> Agendar Texto
                        </button>
                        <button id="whatsappButton" title="Compartilhar via WhatsApp" disabled>
                            <i class="fab fa-whatsapp"></i> WhatsApp
                        </button>
                         <button id="copyTextButton" title="Copiar Texto" disabled>
                            <i class="far fa-copy"></i> Copiar
                        </button>
                    </div>
                </div>
                <h2>Histórico</h2>
                <ul id="historyList">
                    <!-- Itens do histórico serão adicionados aqui pelo JS -->
                    <li class="history-placeholder">Nenhum item no histórico.</li>
                </ul>
            </div>
        </div>

        <div id="status-bar" class="status-info"> <!-- Default class -->
            <span id="status-message">Pronto.</span>
            <span id="auth-status"></span> <!-- Status do Login Google -->
        </div>
    </div>

    <!-- Input de arquivo oculto -->
    <input type="file" id="file-input" accept="audio/*,video/*,text/*,application/pdf,image/*" style="display: none;">

    <!-- Modal de Configurações -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button">×</span>
            <h2>Configurações</h2>
            <p>Configure suas chaves de API e autenticação.</p>
            <div class="form-group">
                <label for="google-client-id-input">Google OAuth Client ID:</label>
                <input type="text" id="google-client-id-input" placeholder="Seu Client ID do Google Cloud">
                <small>Necessário para login e acesso ao Google Calendar.</small>
            </div>
            <div class="form-group">
                <label for="google-api-key-input">Google API Key (Opcional):</label>
                <input type="text" id="google-api-key-input" placeholder="Sua API Key (para Speech API, se não usar OAuth)">
                 <small>Pode ser usada para Speech-to-Text se preferir autenticação por chave.</small>
            </div>
            <!-- Outras configs (ex: idioma transcrição) -->
            <button class="button-primary" id="save-settings-button">Salvar Configurações</button>
            <div class="modal-status" id="settings-modal-status"></div>
        </div>
    </div>

    <!-- Pool de Players (se necessário para histórico) -->
    <div id="audio-player-pool" style="display: none;"></div>

    <!-- Scripts -->
    <script>
        // --- Início do JavaScript Embutido ---
        const app = (() => {
            // --- DOM Elements ---
            const appShell = document.getElementById('app-shell');
            const topBar = {
                backButton: document.getElementById('back-button'),
                title: document.getElementById('app-title'),
                attachButton: document.getElementById('attachButton'),
                themeToggleButton: document.getElementById('themeToggleButton'),
                historyButton: document.getElementById('historyButton'),
                settingsButton: document.getElementById('settingsButton'),
                googleAuthButton: document.getElementById('google-auth-button'),
            };
            const mainContent = document.getElementById('main-content');
            const views = {
                recording: document.getElementById('recording-view'),
                list: document.getElementById('list-view'),
            };
            const recordingView = {
                iconWrapper: document.getElementById('recording-icon-wrapper'),
                icon: document.getElementById('recording-icon'),
                timer: document.getElementById('timer-recording'),
                discardButton: document.getElementById('discardButton'),
                recordPauseResumeButton: document.getElementById('recordPauseResumeButton'),
                stopButton: document.getElementById('stopButton'),
            };
            const listView = {
                transcriptionTextarea: document.getElementById('transcriptionTextarea'),
                manualScheduleButton: document.getElementById('manualScheduleButton'),
                whatsappButton: document.getElementById('whatsappButton'),
                copyTextButton: document.getElementById('copyTextButton'),
                historyList: document.getElementById('historyList'),
                historyPlaceholder: document.querySelector('.history-placeholder'),
            };
            const statusBar = {
                element: document.getElementById('status-bar'),
                message: document.getElementById('status-message'),
                auth: document.getElementById('auth-status'),
            };
            const fileInput = document.getElementById('file-input');
            const settingsModal = {
                element: document.getElementById('settings-modal'),
                content: document.querySelector('#settings-modal .modal-content'),
                closeButton: document.querySelector('#settings-modal .modal-close-button'),
                clientIdInput: document.getElementById('google-client-id-input'),
                apiKeyInput: document.getElementById('google-api-key-input'),
                saveButton: document.getElementById('save-settings-button'),
                status: document.getElementById('settings-modal-status'),
            };
            const audioPlayerPool = document.getElementById('audio-player-pool');

            // --- State ---
            let state = {
                isRecording: false,
                isPaused: false,
                recordingStartTime: null,
                pausedTime: 0,
                timerInterval: null,
                currentBlob: null,
                mediaRecorder: null,
                audioChunks: [],
                stream: null,
                currentView: 'recording', // 'recording' or 'list'
                historyItems: [], // Array to hold history data
                googleUser: null, // Holds Google User Profile
                gapiReady: false,
                googleApiClientId: null,
                googleApiKey: null, // Optional
                isProcessing: false, // General processing flag
            };

            // --- Constants ---
            const HISTORY_STORAGE_KEY = 'intelligentRecorderHistory_v9';
            const SETTINGS_STORAGE_KEY = 'intelligentRecorderSettings_v9';

            // --- Initialization ---
            function init() {
                console.log("App initializing...");
                loadSettings(); // Load API keys first
                setupEventListeners();
                // Delay Google Auth init until gapi is likely loaded
                // Or rely on the explicit gapi.load callback
                if (typeof gapi !== 'undefined') {
                    initGoogleAuth();
                } else {
                    // Check again after a short delay if gapi wasn't ready immediately
                    // This is a fallback, the defer script should handle it mostly
                    setTimeout(() => {
                         if (typeof gapi !== 'undefined') {
                            initGoogleAuth();
                         } else {
                            console.error("Google API script not loaded after delay.");
                             updateAuthStatus('Falha Google API', true);
                         }
                    }, 1500);
                }
                loadHistory();
                applyTheme(localStorage.getItem('theme') || 'light'); // Apply saved theme
                showView('recording'); // Explicitly show recording view initially
                updateUI();
                updateStatus('Pronto.', 'info');
            }

            // --- Event Listeners Setup ---
            function setupEventListeners() {
                // Top Bar
                topBar.backButton.addEventListener('click', () => showView('recording'));
                topBar.attachButton.addEventListener('click', () => fileInput.click());
                topBar.themeToggleButton.addEventListener('click', toggleTheme);
                topBar.historyButton.addEventListener('click', () => showView('list'));
                topBar.settingsButton.addEventListener('click', openSettingsModal);
                topBar.googleAuthButton.addEventListener('click', handleAuthClick);

                // Recording View
                recordingView.recordPauseResumeButton.addEventListener('click', handleRecordPauseResume);
                recordingView.stopButton.addEventListener('click', stopRecording);
                recordingView.discardButton.addEventListener('click', discardRecording);

                // List View
                listView.manualScheduleButton.addEventListener('click', () => {
                    const text = listView.transcriptionTextarea.value;
                    if (text) attemptAutomaticScheduling(text, true); // Force attempt
                });
                listView.whatsappButton.addEventListener('click', shareViaWhatsApp);
                listView.copyTextButton.addEventListener('click', copyTranscription);
                listView.historyList.addEventListener('click', handleHistoryAction); // Event delegation

                // File Input
                fileInput.addEventListener('change', handleFileAttachment);

                // Settings Modal
                settingsModal.closeButton.addEventListener('click', closeSettingsModal);
                settingsModal.saveButton.addEventListener('click', saveSettings);
                settingsModal.element.addEventListener('click', (e) => { // Close on overlay click
                    if (e.target === settingsModal.element) closeSettingsModal();
                });
            }

            // --- Google Authentication & API ---
            function initGoogleAuth() {
                console.log("Attempting to initialize Google Auth...");
                if (!state.googleApiClientId) {
                     updateAuthStatus('ClientID não configurado.');
                     console.warn("Google Client ID not set in settings.");
                     state.gapiReady = false;
                     return;
                }
                 updateAuthStatus('Inicializando Google API...');
                 // Ensure gapi is loaded before calling load
                 if (typeof gapi === 'undefined' || typeof gapi.load === 'undefined') {
                      console.error("gapi or gapi.load is not available yet.");
                      updateAuthStatus('Erro Google API (gapi)', true);
                      return;
                 }

                gapi.load('client:auth2', () => {
                     console.log("gapi client:auth2 loaded.");
                     gapi.client.init({
                         apiKey: state.googleApiKey || null, // API Key might be needed for some APIs, but Calendar uses OAuth
                         clientId: state.googleApiClientId,
                         discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"],
                         scope: "https://www.googleapis.com/auth/calendar.events" // Scope for creating events
                     }).then(() => {
                         console.log("Google API client initialized.");
                         state.gapiReady = true;
                         // Listen for sign-in state changes.
                         gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);
                         // Handle the initial sign-in state.
                         updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
                     }, (error) => {
                         console.error("Error initializing Google API client: ", error);
                         updateAuthStatus('Erro Google API', true);
                         updateStatus(`Erro Google API: ${JSON.stringify(error)}`, 'error');
                         state.gapiReady = false;
                     });
                 });
            }

            function updateSigninStatus(isSignedIn) {
                if (isSignedIn) {
                     try {
                        state.googleUser = gapi.auth2.getAuthInstance().currentUser.get().getBasicProfile();
                        console.log('User signed in.', state.googleUser);
                        updateAuthStatus(`Logado: ${state.googleUser.getName()}`);
                        topBar.googleAuthButton.classList.add('logged-in');
                        topBar.googleAuthButton.title = `Logado como ${state.googleUser.getName()}. Clique para Sair.`;
                     } catch(e) {
                        console.error("Error getting user profile:", e);
                        updateAuthStatus('Logado (erro perfil)', true);
                         topBar.googleAuthButton.classList.add('logged-in'); // Still show logged in
                     }
                } else {
                    console.log('User signed out.');
                    state.googleUser = null;
                    updateAuthStatus('Não Logado');
                     topBar.googleAuthButton.classList.remove('logged-in');
                     topBar.googleAuthButton.title = 'Login com Google';
                }
                updateUI(); // Update buttons potentially dependent on login state
            }

            function handleAuthClick() {
                 if (typeof gapi === 'undefined' || typeof gapi.auth2 === 'undefined' || !gapi.auth2.getAuthInstance) {
                      updateStatus('Google Auth não inicializado corretamente.', 'error');
                      console.error("Google Auth instance not ready for click.");
                      return;
                 }
                if (!state.gapiReady) {
                    updateStatus('Google API não está pronta. Verifique config/conexão.', 'warning');
                    return;
                }
                if (gapi.auth2.getAuthInstance().isSignedIn.get()) {
                    // Sign out
                    gapi.auth2.getAuthInstance().signOut();
                } else {
                    // Sign in
                    gapi.auth2.getAuthInstance().signIn();
                }
            }

            function updateAuthStatus(text, isError = false) {
                statusBar.auth.textContent = text;
                statusBar.auth.style.color = isError ? 'var(--danger-color)' : 'var(--secondary-color)';
                if (document.body.classList.contains('dark-mode')) {
                     statusBar.auth.style.color = isError ? '#ff6b6b' : '#adb5bd'; // Dark mode colors
                }
            }

            // --- Theme ---
            function applyTheme(themeName) {
                document.body.className = themeName === 'dark' ? 'dark-mode' : '';
                topBar.themeToggleButton.innerHTML = themeName === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
                localStorage.setItem('theme', themeName);
                 updateAuthStatus(statusBar.auth.textContent); // Re-apply auth status color for new theme
            }
            function toggleTheme() {
                const currentTheme = document.body.classList.contains('dark-mode') ? 'dark' : 'light';
                applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
            }

            // --- View Management ---
            function showView(viewId) {
                 console.log(`Showing view: ${viewId}`);
                state.currentView = viewId;
                appShell.classList.toggle('show-list', viewId === 'list');

                 // This part is now handled by the CSS based on .show-list class on #app-shell
                // Object.values(views).forEach(view => view.classList.remove('active-view'));
                // if (views[viewId]) {
                //     views[viewId].classList.add('active-view');
                // }

                topBar.title.textContent = viewId === 'list' ? 'Histórico / Texto' : 'Gravar';
                topBar.backButton.style.display = viewId === 'list' ? 'inline-block' : 'none';
                topBar.historyButton.style.display = viewId === 'list' ? 'none' : 'inline-block';
                updateUI(); // Update buttons based on view
            }

             // --- Status Updates ---
            function updateStatus(message, type = 'info') {
                console.log(`Status (${type}): ${message}`);
                statusBar.message.textContent = message;
                // Remove existing status classes before adding new one
                statusBar.element.classList.remove('status-info', 'status-success', 'status-error', 'status-loading', 'status-warning');
                if (type !== 'info') { // 'info' is the default style
                    statusBar.element.classList.add(`status-${type}`);
                }
            }

            // --- UI State Updates ---
            function updateUI() {
                // Recording View Buttons
                recordingView.recordPauseResumeButton.disabled = state.isProcessing;
                recordingView.stopButton.disabled = (!state.isRecording && !state.isPaused) || state.isProcessing;
                recordingView.discardButton.disabled = (!state.isRecording && !state.isPaused) || state.isProcessing;


                // Recording Icon & Button State
                const recIcon = recordingView.icon;
                const recButton = recordingView.recordPauseResumeButton;
                // Clear previous state classes from icon
                recIcon.classList.remove('fa-microphone', 'fa-microphone-alt', 'fa-microphone-slash', 'fa-spinner', 'fa-spin', 'fa-calendar-alt', 'state-idle', 'state-recording', 'state-paused', 'state-processing', 'state-analyzing');
                 // Clear previous state classes from button icon (use child selector)
                const recButtonIcon = recButton.querySelector('i');
                 if(recButtonIcon) recButtonIcon.className = 'fas'; // Reset button icon classes

                // Clear state classes from main button
                recButton.classList.remove('state-idle', 'state-recording', 'state-paused', 'state-processing');


                if (state.isProcessing) {
                    recIcon.classList.add('fas', 'fa-spinner', 'fa-spin', 'state-processing'); // Use spinner for processing
                    recButton.classList.add('state-processing');
                     if (recButtonIcon) recButtonIcon.classList.add('fa-spinner', 'fa-spin');
                    recButton.title = 'Processando...';
                } else if (state.isRecording) {
                    recIcon.classList.add('fas', 'fa-microphone-alt', 'state-recording'); // Indicate active recording
                    recButton.classList.add('state-recording'); // Show Pause icon style
                     if (recButtonIcon) recButtonIcon.classList.add('fa-pause');
                    recButton.title = 'Pausar';
                } else if (state.isPaused) {
                    recIcon.classList.add('fas', 'fa-microphone-slash', 'state-paused'); // Indicate paused
                    recButton.classList.add('state-paused'); // Show Play (Resume) icon style
                    if (recButtonIcon) {
                        recButtonIcon.classList.add('fa-play');
                        recButtonIcon.style.marginLeft = '3px'; // Keep play icon centered
                    } else {
                         recButton.innerHTML = '<i class="fas fa-play" style="margin-left: 3px;"></i>'; // Add if missing
                    }
                    recButton.title = 'Retomar';
                } else { // Idle state
                    recIcon.classList.add('fas', 'fa-microphone', 'state-idle');
                    recButton.classList.add('state-idle'); // Show Record icon style
                    if (recButtonIcon) {
                         recButtonIcon.classList.add('fa-microphone');
                         recButtonIcon.style.marginLeft = '0'; // Reset margin
                     } else {
                         recButton.innerHTML = '<i class="fas fa-microphone"></i>'; // Add if missing
                     }
                    recButton.title = 'Gravar';
                    recordingView.timer.textContent = '00:00'; // Reset timer display
                }

                // List View Buttons (enable based on text content and login state)
                const hasText = listView.transcriptionTextarea.value.trim().length > 0;
                const isLoggedIn = state.googleUser !== null && state.gapiReady;

                listView.manualScheduleButton.disabled = !hasText || !isLoggedIn || state.isProcessing;
                listView.whatsappButton.disabled = !hasText || state.isProcessing;
                listView.copyTextButton.disabled = !hasText || state.isProcessing;

                // Disable attach/settings/history during processing
                topBar.attachButton.disabled = state.isProcessing;
                topBar.settingsButton.disabled = state.isProcessing;
                topBar.historyButton.disabled = state.isProcessing;
                 topBar.googleAuthButton.disabled = state.isProcessing; // Disable login/logout too
            }

            // --- Recording Logic ---
            async function handleRecordPauseResume() {
                if (state.isProcessing) return;

                if (state.isRecording) {
                    pauseRecording();
                } else if (state.isPaused) {
                    resumeRecording();
                } else {
                    await startRecording();
                }
                updateUI();
            }

            async function startRecording() {
                // Request microphone permission first
                 if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                     updateStatus('Gravação não suportada neste navegador.', 'error');
                     return;
                 }

                try {
                     updateStatus('Solicitando permissão de microfone...', 'loading');
                    state.stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                     console.log("Microphone permission granted.");
                } catch (err) {
                     console.error("Error getting microphone permission:", err);
                     updateStatus(`Erro de permissão: ${err.message}. Verifique as configurações do navegador.`, 'error');
                     return; // Stop if permission denied
                }

                // Permission granted, proceed with recording setup
                try {
                    updateStatus('Iniciando gravação...', 'loading');
                    state.isProcessing = true; // Prevent clicks during setup
                    updateUI();

                    // Ensure previous stream is stopped (should be handled by reset, but double-check)
                    // if (state.stream) {
                    //     state.stream.getTracks().forEach(track => track.stop());
                    //     state.stream = null;
                    //     console.log("Previous stream stopped before new recording.");
                    // }


                    state.audioChunks = [];
                     const options = { mimeType: 'audio/webm;codecs=opus' }; // Be explicit if possible
                     try {
                        state.mediaRecorder = new MediaRecorder(state.stream, options);
                     } catch (e) {
                        console.warn("WebM/Opus not supported, trying default.", e);
                         try {
                           state.mediaRecorder = new MediaRecorder(state.stream); // Fallback to browser default
                         } catch (e2) {
                           console.error("MediaRecorder not supported with available stream/codecs:", e2);
                           updateStatus('Erro fatal: Gravador não suportado.', 'error');
                           resetRecordingState();
                           state.isProcessing = false;
                           updateUI();
                           return;
                         }
                     }
                     console.log("Using mimeType:", state.mediaRecorder.mimeType);


                    state.mediaRecorder.ondataavailable = event => {
                        if (event.data.size > 0) {
                            state.audioChunks.push(event.data);
                        }
                    };

                    state.mediaRecorder.onstop = async () => {
                        console.log("MediaRecorder stopped.");
                         // state.isProcessing = true; // Set processing true BEFORE async operations
                         // updateUI(); // Already set in stopRecording
                         updateStatus('Gravação finalizada. Processando...', 'loading');

                         if (state.audioChunks.length === 0) {
                              console.warn("No audio chunks recorded.");
                              updateStatus('Nenhum áudio gravado.', 'warning');
                              resetRecordingState();
                              state.isProcessing = false;
                              updateUI();
                              return;
                         }

                        state.currentBlob = new Blob(state.audioChunks, { type: state.mediaRecorder.mimeType || 'audio/webm' });
                        const fileName = `gravacao-${Date.now()}.${state.currentBlob.type.split('/')[1].split(';')[0] || 'webm'}`; // Filename with extension
                        state.audioChunks = []; // Clear chunks

                        // --- A MÁGICA ACONTECE AQUI ---
                        await processAudioData(state.currentBlob, fileName);
                        // --- FIM DA MÁGICA ---

                         // Reset state AFTER processing is fully complete (including scheduling attempt)
                         resetRecordingState(); // This stops timer etc.
                         updateStatus('Processamento concluído.', 'success');
                         state.isProcessing = false;
                         updateUI();

                         // Optionally switch to list view
                         showView('list');
                    };

                    state.mediaRecorder.onerror = error => {
                        console.error("MediaRecorder Error:", error);
                        updateStatus(`Erro no gravador: ${error.name} - ${error.message}`, 'error');
                        resetRecordingState();
                        state.isProcessing = false;
                        updateUI();
                    };

                    state.mediaRecorder.start(1000); // Start recording, chunk every second (optional)
                    state.isRecording = true;
                    state.isPaused = false;
                    state.recordingStartTime = Date.now();
                    state.pausedTime = 0;
                    startTimer();
                    updateStatus('Gravando...', 'info');
                    state.isProcessing = false; // Re-enable controls after setup

                } catch (err) {
                    console.error("Error setting up MediaRecorder:", err);
                    updateStatus(`Erro ao iniciar gravação: ${err.message}.`, 'error');
                     resetRecordingState(); // Ensure clean state on error
                     state.isProcessing = false; // Ensure controls are re-enabled
                     updateUI();
                }
            }

            function pauseRecording() {
                if (!state.isRecording || state.isPaused || !state.mediaRecorder || state.mediaRecorder.state !== 'recording') return;
                 try {
                    state.mediaRecorder.pause();
                    state.isPaused = true;
                    state.pausedTime += Date.now() - state.recordingStartTime; // Accumulate recorded time before pause
                    stopTimer();
                    updateStatus('Gravação pausada.', 'warning');
                    console.log("Recording paused");
                 } catch(e) {
                     console.error("Error pausing recorder:", e);
                     updateStatus('Erro ao pausar.', 'error');
                 }
            }

            function resumeRecording() {
                if (!state.isPaused || !state.mediaRecorder || state.mediaRecorder.state !== 'paused') return;
                 try {
                    state.mediaRecorder.resume();
                    state.isPaused = false;
                    state.recordingStartTime = Date.now(); // Reset start time for the current segment
                    startTimer();
                    updateStatus('Retomando gravação...', 'info');
                    console.log("Recording resumed");
                } catch(e) {
                     console.error("Error resuming recorder:", e);
                     updateStatus('Erro ao retomar.', 'error');
                }
            }

            function stopRecording() {
                if ((!state.isRecording && !state.isPaused) || state.isProcessing || !state.mediaRecorder) return;

                if (state.mediaRecorder.state === "inactive") {
                    console.warn("Stop called on inactive recorder.");
                    // Should already be processing or idle, reset just in case
                     resetRecordingState();
                     state.isProcessing = false;
                     updateUI();
                    return;
                }

                 updateStatus('Finalizando gravação...', 'loading');
                 state.isProcessing = true; // Prevent further actions until stop completes
                 updateUI();

                // Stop the MediaRecorder. The 'onstop' event will handle processing.
                 try {
                    state.mediaRecorder.stop(); // onstop handler takes over from here
                 } catch(e) {
                    console.error("Error stopping recorder:", e);
                     updateStatus('Erro ao parar gravação.', 'error');
                     // Attempt manual cleanup if stop failed badly
                     resetRecordingState();
                     state.isProcessing = false;
                     updateUI();
                 }

                // Stop the tracks now, don't wait for onstop (camera light off sooner)
                if (state.stream) {
                    state.stream.getTracks().forEach(track => track.stop());
                    state.stream = null;
                     console.log("Stream tracks stopped.");
                }

                // Timer stops via onstop -> resetRecordingState
            }

             function discardRecording() {
                 if (!state.isRecording && !state.isPaused || state.isProcessing) return;
                 updateStatus('Gravação descartada.', 'info');

                 if (state.mediaRecorder && state.mediaRecorder.state !== "inactive") {
                     state.mediaRecorder.onstop = null; // Prevent processing on stop
                      try { state.mediaRecorder.stop(); } catch(e) { console.warn("Minor error stopping recorder during discard:", e); }
                 }
                 if (state.stream) {
                      state.stream.getTracks().forEach(track => track.stop());
                 }

                 resetRecordingState(); // Reset everything without processing
                 updateUI();
             }

            function resetRecordingState() {
                stopTimer();
                // No need to stop recorder/stream here, should be done by stop/discard caller
                state.isRecording = false;
                state.isPaused = false;
                state.recordingStartTime = null;
                state.pausedTime = 0;
                state.currentBlob = null;
                state.mediaRecorder = null; // Crucial to release
                state.audioChunks = [];
                state.stream = null; // Crucial to release
                 recordingView.timer.textContent = '00:00'; // Ensure timer display is reset
                // Don't reset isProcessing here, let the calling function handle it AFTER async tasks finish
            }

            // --- Timer ---
            function startTimer() {
                stopTimer(); // Clear existing interval if any
                // Update immediately only if starting from 0
                 if(state.pausedTime === 0) updateTimerDisplay();
                state.timerInterval = setInterval(updateTimerDisplay, 1000);
            }

            function stopTimer() {
                clearInterval(state.timerInterval);
                state.timerInterval = null;
            }

            function updateTimerDisplay() {
                 // Update display even if paused, based on accumulated time
                const elapsedMilliseconds = state.pausedTime + (state.isRecording ? (Date.now() - state.recordingStartTime) : 0);
                const totalSeconds = Math.floor(elapsedMilliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                recordingView.timer.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            // --- File Handling & Processing ---
            async function handleFileAttachment(event) {
                 if (state.isProcessing) return;
                const file = event.target.files[0];
                if (!file) return;

                console.log(`File attached: ${file.name}, Type: ${file.type}`);
                state.isProcessing = true;
                updateStatus(`Processando anexo: ${file.name}...`, 'loading');
                updateUI();
                listView.transcriptionTextarea.value = ''; // Clear previous text

                try {
                    // Simplify type checking
                     const fileType = getFileTypeFromFile(file);

                     switch(fileType) {
                          case 'audio':
                          case 'video': // Treat video as audio source for transcription
                               await processAudioData(file, file.name);
                               break;
                          case 'text':
                               const textContent = await file.text();
                               await processTranscriptionResult(textContent, file.name, 'text');
                               break;
                          case 'pdf':
                               updateStatus('Transcrição de PDF não implementada.', 'warning');
                               await processTranscriptionResult(`[Conteúdo do PDF: ${file.name}]`, file.name, 'document');
                               break;
                          case 'image':
                               updateStatus('Transcrição de Imagem (OCR) não implementada.', 'warning');
                               await processTranscriptionResult(`[Conteúdo da Imagem: ${file.name}]`, file.name, 'image');
                               break;
                          default: // 'document' or other unsupported
                               updateStatus(`Tipo de arquivo não suportado para transcrição direta: ${file.type}`, 'warning');
                               await processTranscriptionResult(`[Arquivo Anexado: ${file.name}]`, file.name, 'document');
                               break;
                     }

                    updateStatus('Anexo processado.', 'success');
                    showView('list'); // Show result

                } catch (error) {
                    console.error("Error processing attachment:", error);
                    updateStatus(`Erro ao processar ${file.name}: ${error.message}`, 'error');
                } finally {
                    fileInput.value = ''; // Reset input for next selection
                    state.isProcessing = false;
                    updateUI();
                }
            }

             // Helper to determine general file type
             function getFileTypeFromFile(file) {
                 if (!file || !file.type) return 'document';
                 if (file.type.startsWith('audio/')) return 'audio';
                 if (file.type.startsWith('video/')) return 'video'; // Can be used for transcription
                 if (file.type.startsWith('text/')) return 'text';
                 if (file.type === 'application/pdf') return 'pdf';
                 if (file.type.startsWith('image/')) return 'image';
                 return 'document'; // Default
             }


            async function processAudioData(blobOrFile, fileName) {
                updateStatus('Transcrevendo áudio...', 'loading');
                 recordingView.icon.classList.add('fas', 'fa-spinner', 'fa-spin', 'state-processing');
                 recordingView.icon.classList.remove('state-idle', 'state-paused', 'state-recording'); // Ensure only spinner shows

                try {
                     // ******** REAL TRANSCRIPTION API CALL GOES HERE ********
                     // const transcription = await callGoogleSpeechToTextAPI(blobOrFile);
                     const transcription = await callPlaceholderTranscription(blobOrFile, fileName); // Using placeholder
                     // ******** END OF API CALL ***************************

                      // Determine type more reliably for history
                     const itemType = blobOrFile.type.startsWith('audio/') ? 'audio' : (blobOrFile.type.startsWith('video/') ? 'video' : 'document');
                     await processTranscriptionResult(transcription, fileName, itemType, blobOrFile); // Pass blob for history linking if needed

                } catch (error) {
                    console.error("Transcription Error:", error);
                    updateStatus(`Erro na transcrição: ${error.message}`, 'error');
                    const itemType = blobOrFile.type.startsWith('audio/') ? 'audio' : (blobOrFile.type.startsWith('video/') ? 'video' : 'document');
                    await processTranscriptionResult(`[Erro na transcrição de ${fileName}: ${error.message}]`, fileName, itemType, blobOrFile);
                } finally {
                     // Reset icon after processing - handled by updateUI() called later
                }
            }

             // Placeholder for actual Speech-to-Text API call
            async function callPlaceholderTranscription(blobOrFile, fileName) {
                 console.log(`Placeholder: Transcribing ${fileName} (Size: ${blobOrFile.size} bytes, Type: ${blobOrFile.type})...`);
                 await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1500)); // Simulate API delay
                 // Simulate some realistic-ish text extraction
                 const randomPhrases = [
                     "Ok, agendar reunião com a equipe de marketing amanhã às 14h para discutir a nova campanha.",
                     "Lembrete: comprar pão e leite no supermercado hoje à noite.",
                     "Enviar email para o cliente sobre o status do projeto na sexta-feira.",
                     "Discussão sobre o orçamento trimestral, precisamos finalizar até quarta-feira que vem.",
                     `Áudio referente ao arquivo ${fileName}. Conteúdo principal sobre planejamento estratégico.`
                 ];
                 return randomPhrases[Math.floor(Math.random() * randomPhrases.length)];
             }

            // TODO: Replace with actual Google Cloud Speech-to-Text API call
             async function callGoogleSpeechToTextAPI(blobOrFile) {
                 updateStatus('Enviando para Google Speech API...', 'loading');
                 const apiKey = state.googleApiKey;
                 if (!apiKey) {
                     throw new Error("Chave API do Google Speech não configurada.");
                 }

                 const base64Audio = await new Promise((resolve, reject) => {
                     const reader = new FileReader();
                     reader.onloadend = () => resolve(reader.result.split(',')[1]);
                     reader.onerror = reject;
                     reader.readAsDataURL(blobOrFile);
                 });

                 const requestBody = {
                     config: {
                         languageCode: 'pt-BR',
                         enableAutomaticPunctuation: true,
                         encoding: '', // Determine below
                         // sampleRateHertz: 48000, // Optional: Get from AudioContext if possible/needed
                     },
                     audio: { content: base64Audio }
                 };

                // Basic encoding detection from MIME type
                const mime = blobOrFile.type.toLowerCase();
                if (mime.includes('webm')) requestBody.config.encoding = 'WEBM_OPUS';
                else if (mime.includes('wav')) requestBody.config.encoding = 'LINEAR16';
                else if (mime.includes('mp3')) requestBody.config.encoding = 'MP3';
                else if (mime.includes('ogg')) requestBody.config.encoding = 'OGG_OPUS';
                else if (mime.includes('flac')) requestBody.config.encoding = 'FLAC';
                else if (mime.includes('amr')) requestBody.config.encoding = 'AMR';
                 else {
                      console.warn(`Tipo MIME não mapeado diretamente para encoding: ${mime}. Usando ENCODING_UNSPECIFIED.`);
                      requestBody.config.encoding = 'ENCODING_UNSPECIFIED';
                 }
                 console.log("Using encoding:", requestBody.config.encoding);


                 const API_ENDPOINT = `https://speech.googleapis.com/v1/speech:recognize?key=${apiKey}`;
                 const response = await fetch(API_ENDPOINT, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify(requestBody)
                 });

                 const data = await response.json();

                 if (!response.ok || data.error) {
                     console.error("Google Speech API Error:", data.error || data);
                     throw new Error(`Google Speech API: ${data.error?.message || JSON.stringify(data.error) || 'Erro desconhecido'}`);
                 }

                 if (data.results && data.results.length > 0 && data.results[0].alternatives && data.results[0].alternatives.length > 0) {
                     const transcription = data.results.map(result => result.alternatives[0].transcript).join('\n'); // Join results if multiple
                     console.log("Google Speech API Transcription:", transcription);
                     updateStatus('Transcrição Google recebida.', 'success');
                     return transcription;
                 } else {
                     console.warn("Google Speech API - No transcription result:", data);
                     return "[Nenhuma transcrição recebida da API]";
                 }
             }


            async function processTranscriptionResult(text, sourceName, itemType, sourceBlob = null) {
                 listView.transcriptionTextarea.value = text || ''; // Update textarea
                 updateStatus('Transcrição carregada.', 'info');

                 // Handle Blob URL for history (use cautiously - memory implications)
                 let blobUrl = null;
                 if (sourceBlob && (itemType === 'audio' || itemType === 'video')) {
                      // TODO: Decide if storing Blob URLs is desired/feasible.
                      // They are temporary and tied to the current document session.
                      // Saving them long-term requires storing the Blob itself (e.g., IndexedDB).
                      // For now, we won't store the URL long-term.
                      // blobUrl = URL.createObjectURL(sourceBlob);
                 }

                 // Add to history
                 const historyItem = {
                     id: `${itemType}-${Date.now()}`,
                     type: itemType, // 'audio', 'video', 'text', 'document', 'image', 'pdf'
                     name: sourceName,
                     date: new Date().toISOString(),
                     transcription: text || '',
                     // blobUrl: blobUrl // Not saving long-term by default
                 };
                 await addToHistory(historyItem);

                 // Attempt automatic scheduling
                 if (text) {
                     await attemptAutomaticScheduling(text);
                 } else {
                      console.log("Texto vazio, pulando agendamento automático.");
                 }
                 updateUI(); // Enable/disable buttons based on new text
            }

            // --- History Management ---
            async function addToHistory(itemData) {
                 console.log("Adding to history:", itemData);
                 state.historyItems.unshift(itemData);
                 renderHistoryList();
                 await saveHistory(); // Persist
            }

            function renderHistoryList() {
                listView.historyList.innerHTML = ''; // Clear current list
                if (state.historyItems.length === 0) {
                    listView.historyList.appendChild(createPlaceholderLi("Nenhum item no histórico."));
                } else {
                    state.historyItems.forEach(item => {
                        const li = createHistoryLi(item);
                        listView.historyList.appendChild(li);
                    });
                }
            }

             function createPlaceholderLi(text) {
                 const li = document.createElement('li');
                 li.className = 'history-placeholder';
                 li.textContent = text;
                 return li;
             }

            function createHistoryLi(item) {
                const li = document.createElement('li');
                li.dataset.id = item.id;
                li.className = `history-item type-${item.type}`;

                // Sanitize transcription slightly for display (prevent basic HTML injection)
                 const safeTranscription = item.transcription
                     ? item.transcription.replace(/</g, "<").replace(/>/g, ">")
                     : 'Sem transcrição.';
                 const shortTranscription = safeTranscription.substring(0, 250) + (safeTranscription.length > 250 ? '...' : '');

                 const safeName = item.name ? item.name.replace(/</g, "<").replace(/>/g, ">") : 'Desconhecido';


                li.innerHTML = `
                    <div class="history-info">
                        <span class="item-type type-${item.type}">${item.type.toUpperCase()}</span>
                        <span class="date-time">${new Date(item.date).toLocaleString('pt-BR', { dateStyle: 'short', timeStyle: 'short' })}</span>
                        <span class="item-name" title="${safeName}">${safeName}</span>
                    </div>
                    ${item.transcription ? `<div class="history-transcription">${shortTranscription}</div>` : ''}
                    <div class="history-actions">
                        ${(item.type === 'audio' || item.type === 'video') /*&& item.blobUrl*/ ? '<button class="play-history-btn" title="Reproduzir (Não impl.)" disabled><i class="fas fa-play"></i></button>' : ''}
                        <button class="load-history-btn" title="Carregar Texto" ${!item.transcription ? 'disabled' : ''}><i class="fas fa-file-alt"></i></button>
                        <button class="schedule-history-btn" title="Tentar Re-agendar" ${!item.transcription ? 'disabled' : ''}><i class="far fa-calendar-plus"></i></button>
                        <button class="delete-history-btn" title="Excluir"><i class="fas fa-trash"></i></button>
                    </div>
                `;
                return li;
            }

            function handleHistoryAction(event) {
                const button = event.target.closest('button');
                if (!button || button.disabled) return; // Ignore clicks on disabled buttons or outside buttons
                const li = event.target.closest('li[data-id]'); // Ensure we get the li with data-id
                const itemId = li?.dataset.id;
                if (!itemId) return;

                const item = state.historyItems.find(h => h.id === itemId);
                if (!item) return;

                if (button.classList.contains('load-history-btn')) {
                    listView.transcriptionTextarea.value = item.transcription || '';
                     updateStatus(`Texto de "${item.name}" carregado.`, 'info');
                     showView('list'); // Ensure list view is shown
                     listView.transcriptionTextarea.focus();
                     updateUI(); // Update button states
                } else if (button.classList.contains('schedule-history-btn')) {
                     if (item.transcription) {
                         attemptAutomaticScheduling(item.transcription, true); // Force attempt
                     } else {
                         updateStatus('Não há transcrição para agendar.', 'warning');
                     }
                } else if (button.classList.contains('delete-history-btn')) {
                     // Use a more subtle confirmation maybe? For now, standard confirm.
                     if (confirm(`Tem certeza que deseja excluir o item "${item.name}"?`)) {
                         deleteHistoryItem(itemId);
                     }
                } else if (button.classList.contains('play-history-btn')) {
                     // TODO: Implement playback from saved blobUrl if available/implemented
                     updateStatus('Reprodução do histórico ainda não implementada.', 'warning');
                }
            }

             async function deleteHistoryItem(itemId) {
                 state.historyItems = state.historyItems.filter(item => item.id !== itemId);
                 renderHistoryList();
                 await saveHistory();
                 updateStatus('Item excluído do histórico.', 'info');
             }

            async function saveHistory() {
                try {
                    // Don't save blobs directly in localStorage (too large)
                    // Only save metadata and transcription
                    const historyToSave = state.historyItems.map(item => ({ ...item, blobUrl: undefined })); // Ensure blobUrl is not saved
                    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(historyToSave));
                } catch (e) {
                    console.error("Error saving history:", e);
                     updateStatus('Erro ao salvar histórico (limite pode ter sido excedido).', 'error');
                     // Maybe prune older items if storage limit is hit
                }
            }

            function loadHistory() {
                const savedHistory = localStorage.getItem(HISTORY_STORAGE_KEY);
                if (savedHistory) {
                    try {
                        state.historyItems = JSON.parse(savedHistory);
                        // Ensure no blobUrls accidentally persist from older versions
                        state.historyItems.forEach(item => item.blobUrl = undefined);
                    } catch (e) {
                        console.error("Error parsing saved history:", e);
                        state.historyItems = [];
                         localStorage.removeItem(HISTORY_STORAGE_KEY); // Clear corrupted data
                    }
                } else {
                    state.historyItems = [];
                }
                 // Sort history by date descending just in case it got out of order
                 state.historyItems.sort((a, b) => new Date(b.date) - new Date(a.date));
                renderHistoryList();
                console.log(`Loaded ${state.historyItems.length} items from history.`);
            }

            // --- Scheduling Logic ---
            async function attemptAutomaticScheduling(text, forceAttempt = false) {
                if (!text) return;
                 if (!state.googleUser) {
                     if (forceAttempt) updateStatus('Faça login com Google para agendar.', 'warning');
                     else console.log("Usuário não logado, pulando agendamento automático.");
                     return;
                 }
                if (!state.gapiReady) {
                     updateStatus('Google Calendar API não pronta.', 'warning');
                     return;
                 }
                 if (state.isProcessing) {
                     console.log("Scheduling skipped: another process is running.");
                     return;
                 }

                state.isProcessing = true; // Prevent other actions during scheduling attempt
                 updateStatus('Analisando texto para agendamento...', 'loading');
                 updateUI(); // Show processing state
                 // recordingView.icon.className = 'fas fa-calendar-alt state-analyzing'; // Update icon to show analysis

                try {
                    // ******** TEXT ANALYSIS FOR SCHEDULING GOES HERE ********
                    const eventDetails = analyzeTextForEvent_Placeholder(text);
                    // ******** END OF TEXT ANALYSIS ************************

                    if (eventDetails) {
                        updateStatus(`Possível evento: ${eventDetails.summary}. Agendando...`, 'loading');
                         await scheduleOnGoogleCalendar(eventDetails);
                    } else {
                         updateStatus('Nenhum detalhe claro de agendamento encontrado.', 'info');
                         console.log("No actionable event details found in text.");
                    }

                } catch (error) {
                    console.error("Error during scheduling analysis/attempt:", error);
                    updateStatus(`Erro no agendamento: ${error.message}`, 'error');
                } finally {
                     state.isProcessing = false; // Release processing lock
                     updateUI(); // Restore normal UI state
                }
            }

             // Placeholder function for event extraction
            function analyzeTextForEvent_Placeholder(text) {
                 // Improved Regex (still basic):
                 // Looks for "agendar/marcar", followed by description, then day/date, then optional time
                 const regex = /(?:agendar|marcar|reunião)\s+(.+?)\s+(?:para\s+|em\s+)?(amanhã|hoje|segunda|terça|quarta|quinta|sexta|sábado|domingo)(?:-feira)?(?:\s+dia\s+(\d{1,2}))?(?:\s*(?:às|as|@)\s*(\d{1,2})(?::(\d{2}))?)?/i;
                 const match = text.match(regex);

                 if (match) {
                     const summary = match[1].replace(/^(?:com|para)\s+/i, '').trim(); // Clean up summary
                     const dayWord = match[2].toLowerCase();
                     const specificDay = match[3] ? parseInt(match[3], 10) : null; // Day number if specified
                     const hour = match[4] ? parseInt(match[4], 10) : 9; // Default to 9 AM
                     const minute = match[5] ? parseInt(match[5], 10) : 0; // Default to 00 minutes

                      if (hour < 0 || hour > 23 || minute < 0 || minute > 59) return null; // Invalid time

                     const targetDate = getTargetDateFromWord(dayWord, specificDay);
                     if (!targetDate) return null; // Couldn't parse day/date

                     targetDate.setHours(hour, minute, 0, 0);

                      // Check if the calculated date is in the past (relative to start of today)
                      const now = new Date();
                      if (targetDate.getTime() < now.getTime() - (now.getHours()*60*60*1000 + now.getMinutes()*60*1000) ) { // Heuristic: if date is before start of today, assume it meant next week/month
                           console.log("Calculated date is in the past, assuming next occurrence.");
                           // Simple fix: add 7 days if it's a weekday name and in the past
                            if (!specificDay && ['segunda','terça','quarta','quinta','sexta','sábado','domingo'].includes(dayWord)) {
                                 targetDate.setDate(targetDate.getDate() + 7);
                            }
                            // More complex logic needed for specific days in the past (e.g., "dia 5" when today is dia 10) - assume next month? Too complex for placeholder.
                      }


                     const startDate = targetDate.toISOString();
                     // Assume 1 hour duration for simplicity
                     const endDate = new Date(targetDate.getTime() + 60 * 60 * 1000).toISOString();

                     return {
                         summary: summary || 'Evento Agendado', // Default summary if regex captures nothing useful
                         start: { dateTime: startDate, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone }, // Use local timezone
                         end: { dateTime: endDate, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone },
                         description: `Agendado automaticamente a partir da transcrição:\n"${text}"`
                     };
                 }
                 return null; // No match found
             }

             // Helper to convert day words/numbers to dates (improved slightly)
             function getTargetDateFromWord(dayWord, specificDay = null) {
                 const today = new Date();
                 const currentDayOfMonth = today.getDate();
                 const currentMonth = today.getMonth();
                 const currentYear = today.getFullYear();
                 today.setHours(0, 0, 0, 0); // Start of day comparison

                 let targetDate = new Date(today); // Start with today

                 if (specificDay) {
                      // Handle specific day of the month
                      if (specificDay < currentDayOfMonth) {
                          // Assume next month if day is in the past this month
                           targetDate.setMonth(currentMonth + 1);
                      }
                      targetDate.setDate(specificDay);
                      // Check if the resulting date is valid (e.g., not Feb 30)
                       if (targetDate.getDate() !== specificDay) {
                            console.warn(`Invalid date calculation for day ${specificDay}`);
                            return null; // Invalid day for the month
                       }
                       return targetDate;
                 }

                 // Handle day words
                 switch (dayWord) {
                     case 'hoje': return targetDate; // Already set to today
                     case 'amanhã':
                     case 'amanha':
                         targetDate.setDate(currentDayOfMonth + 1);
                         return targetDate;
                     // Weekday logic (finds the *next* occurrence including today if it matches)
                     case 'segunda': return findNextWeekday(today, 1);
                     case 'terça': case 'terca': return findNextWeekday(today, 2);
                     case 'quarta': return findNextWeekday(today, 3);
                     case 'quinta': return findNextWeekday(today, 4);
                     case 'sexta': return findNextWeekday(today, 5);
                     case 'sábado': case 'sabado': return findNextWeekday(today, 6);
                     case 'domingo': return findNextWeekday(today, 0);
                     default: return null; // Unknown word
                 }
             }

            // Helper to find the next occurrence of a specific weekday (0=Sun, 1=Mon...)
            function findNextWeekday(startDate, targetDayOfWeek) {
                const currentDayOfWeek = startDate.getDay();
                const daysToAdd = (targetDayOfWeek - currentDayOfWeek + 7) % 7;
                const resultDate = new Date(startDate);
                resultDate.setDate(startDate.getDate() + daysToAdd);
                return resultDate;
            }


            async function scheduleOnGoogleCalendar(eventDetails) {
                if (!state.gapiReady || !state.googleUser) {
                    throw new Error("Google API ou login não está pronto para agendar.");
                }
                 if (!gapi.client.calendar) {
                     console.error("gapi.client.calendar not loaded!");
                      throw new Error("API do Google Calendar não carregada.");
                 }

                updateStatus(`Agendando "${eventDetails.summary}"...`, 'loading');
                try {
                    const response = await gapi.client.calendar.events.insert({
                        'calendarId': 'primary', // Use primary calendar
                        'resource': eventDetails
                    });

                    console.log('Google Calendar Event created:', response.result);
                     updateStatus(`Evento "${response.result.summary}" agendado!`, 'success');
                     // Maybe add a link to the event? response.result.htmlLink

                } catch (error) {
                    console.error('Error creating Google Calendar event:', error);
                     const errorMsg = error.result?.error?.message || error.message || 'Erro desconhecido';
                     updateStatus(`Falha ao agendar: ${errorMsg}`, 'error');
                     // Re-throw or handle specific errors (like 401/403 for auth) if needed
                }
            }

            // --- Other Actions ---
            function shareViaWhatsApp() {
                 const text = listView.transcriptionTextarea.value;
                 if (!text) return;
                 const whatsappUrl = `https://api.whatsapp.com/send?text=${encodeURIComponent(text)}`;
                 window.open(whatsappUrl, '_blank', 'noopener,noreferrer');
                 updateStatus('Tentando compartilhar via WhatsApp...', 'info');
            }

            function copyTranscription() {
                 const text = listView.transcriptionTextarea.value;
                 if (!text) return;
                 if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(() => {
                        updateStatus('Texto copiado!', 'success');
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        updateStatus('Falha ao copiar texto.', 'error');
                    });
                 } else {
                     // Fallback for older browsers (less reliable)
                     try {
                         listView.transcriptionTextarea.select();
                         document.execCommand('copy');
                         updateStatus('Texto copiado (fallback).', 'success');
                     } catch (err) {
                         console.error('Fallback copy failed: ', err);
                         updateStatus('Falha ao copiar texto.', 'error');
                     }
                 }
            }


            // --- Settings Modal ---
            function openSettingsModal() {
                 settingsModal.clientIdInput.value = state.googleApiClientId || '';
                 settingsModal.apiKeyInput.value = state.googleApiKey || '';
                 settingsModal.status.textContent = '';
                 settingsModal.status.className = 'modal-status'; // Reset status class
                 settingsModal.element.style.display = 'block';
            }

            function closeSettingsModal() {
                settingsModal.element.style.display = 'none';
            }

            function saveSettings() {
                 const oldClientId = state.googleApiClientId;
                state.googleApiClientId = settingsModal.clientIdInput.value.trim();
                state.googleApiKey = settingsModal.apiKeyInput.value.trim();

                const settingsToSave = {
                    googleApiClientId: state.googleApiClientId,
                    googleApiKey: state.googleApiKey,
                };

                try {
                    localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settingsToSave));
                    settingsModal.status.textContent = 'Configurações salvas!';
                    settingsModal.status.className = 'modal-status status-success';

                    // Re-initialize Google Auth ONLY if Client ID changed or was previously null
                    if (state.googleApiClientId && state.googleApiClientId !== oldClientId) {
                         console.log("Client ID changed. Re-initializing Google Auth.");
                         // Sign out existing user if any, before re-init
                         if (state.gapiReady && gapi.auth2?.getAuthInstance()?.isSignedIn.get()) {
                             gapi.auth2.getAuthInstance().signOut();
                         }
                         state.gapiReady = false; // Mark as not ready until re-init finishes
                         initGoogleAuth(); // Try to initialize again with new settings
                    }

                    setTimeout(closeSettingsModal, 1500);
                } catch (e) {
                    console.error("Error saving settings:", e);
                    settingsModal.status.textContent = 'Erro ao salvar configurações.';
                    settingsModal.status.className = 'modal-status status-error';
                }
            }

            function loadSettings() {
                const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
                if (savedSettings) {
                    try {
                        const parsed = JSON.parse(savedSettings);
                        state.googleApiClientId = parsed.googleApiClientId || null;
                        state.googleApiKey = parsed.googleApiKey || null;
                         console.log("Settings loaded:", { googleApiClientId: state.googleApiClientId ? '***' : null, googleApiKey: state.googleApiKey ? '***' : null });
                    } catch (e) {
                        console.error("Error parsing saved settings:", e);
                         localStorage.removeItem(SETTINGS_STORAGE_KEY);
                    }
                }
            }

            // --- Public API (if needed) ---
            return {
                init: init
            };

        })();

        // --- Start the App ---
        // Use DOMContentLoaded to ensure HTML is ready before running JS that interacts with it
        document.addEventListener('DOMContentLoaded', app.init);

        // --- Fim do JavaScript Embutido ---
    </script>

</body>
</html>
